message(paste0("Welcome"))

#source(paste(r_dir, "code.txt", sep = "/"))

#source("C:/Users/gcook/Sync/Progs/R/R-Portable/mypackages/zaatar Scripts/packages.R")
#source("C:/Users/gcook/Sync/Progs/R/R-Portable/mypackages/zaatar Scripts/surveys.R")

#source("C:/Users/gcook/Sync/Progs/R/R-Portable/mypackages/zaatar Scripts/kableExtras.txt")
#source("C:/Users/gcook/Sync/Progs/R/R-Portable/mypackages/zaatar Scripts/ggPlots.txt")
#source("C:/Users/gcook/Sync/Progs/R/R-Portable/mypackages/zaatar Scripts/means.txt")
#source("C:/Users/gcook/Sync/Progs/R/R-Portable/mypackages/zaatar Scripts/kableExtras.txt")
source("https://raw.githubusercontent.com/slicesofdata/zaatar/main/kableExtras.txt")
source("https://raw.githubusercontent.com/slicesofdata/zaatar/main/ggPlots.txt")
source("https://raw.githubusercontent.com/slicesofdata/zaatar/main/means.txt")

#source("https://raw.githubusercontent.com/slicesofdata/zaatar/main/libraries.R") # library updates comment out before knitting
#source("https://raw.githubusercontent.com/slicesofdata/zaatar/main/function_test.R") # run to include in function definitions


gic_functions <- "X:/Data/repos/R/gic_functions.txt"
message(paste0("Function file: ", gic_functions))


my.packages <- function() {
    `%notin%` <- Negate(`%in%`)
    pkgs = as.data.frame(installed.packages()[,c(1,3:4)])
    pkgs = pkgs[is.na(pkgs$Priority),1:2, drop = F]
    pkgs = as.vector(as.character(pkgs$Package))
    return(pkgs) }




#options(repos = "https://cran.rstudio.com")
#if (Sys.info()[[8]] %in% c("GCook","cookprojects")) {
#  stopifnot(TRUE, FALSE)
#}
message(paste0("Welcome...", Sys.info()[[8]]))
message(R.Version()$version.string)

#setRepositories(graphics = getOption("menu.graphics"),
#                ind = NULL, addURLs = character())


message("Making backup (.bkup) file of functions")
source.it <- function(file = "X:/Data/repos/R/gic_functions.txt") {
    if (file.exists(file)) {
	file.backup = gsub(".txt", ".bkup", file)
    	file.copy(file, file.backup, overwrite = T)
    }
    if (file.exists(file.backup)) {
	source(file.backup) # Get the functions
    }}

# fast read and write of csv
DT.csv <- function(x, read = T, file, row.names = F, verbose = T, ...) {
    if (read) { data.table::fread(file) } 
    else { data.table::fwrite(x, file, row.names = row.names, verbose = verbose) } 
}

#stopifnot(file.exists(gsub(".txt", ".bkup", "X:/Data/repos/R/gic_functions.txt")))
#
# get the package list and copy if desired.
package.copy <- function(copy = F, overwrite = F, from = "test", to = "new") {
    pkgs = as.data.frame(installed.packages()[,c(1,3:4)])
    pkgs = pkgs[is.na(pkgs$Priority),1:2, drop = F]
    pkgs = as.vector(as.character(pkgs$Package))

    Rdir = "C:/Users/gcook/Sync/Progs/_install/R/R-Portable/"
    if (copy) {
        file.copy(paste0(Rdir,from,"/App/R-Portable/library"),
            paste0(Rdir,to,"/App/R-Portable/library"),
            overwrite = overwrite, recursive = T)
    }
    return(pkgs)
}


	
#If (file.exists("gic_functions.bkup")) { }

functions.from.file <- function(filename) {
# Get all functions from a source file. Create new enviroment
# source the functions into them and use ls() to extract names.
  e = new.env()
  source(filename, local = e)
  return(ls(envir = e))
}

Rfiles = list.files(".", pattern = ".R")
#txtfiles = list.files(".", pattern = ".R")
# Get a list of functions for each .R file
#lutFunc2sourcefile = ldply(list.files(".", pattern = ".R"), function(x) {
#  return(data.frame(fname = x, func = functionsFromRfile(x)))
#})



# https://www.r-statistics.com/2013/03/updating-r-from-r-on-windows-using-the-installr-package/
# http://www.ats.ucla.edu/stat/r/icu/updating_win.htm

# updating R packages
# pckstoinstall <- as.vector(installed.packages()[,1]); update.packages()

# https://ismayc.github.io/moderndiver-book/4-viz.html#resources

usr <- tolower(Sys.getenv("USERNAME"))
message(paste0("Welcome ", Sys.info()[8],"."))
message("Loading...")

str_replace_dots <- function(x, pattern = "(\\.)+" ) { 
    # default is dots "(\\.)+"; can be changed
    x = gsub(x, pattern = pattern, replacement = " ") # clean the dots
    x = gsub(x, pattern = pattern, replacement = "")  # clean trailing space
}


#if(Sys.info()[8] %in% c("GCook","cookprojects")) {
#    gdir <- "G:/"; xdir <- "X:/"; sdir <- "S:/"
#    if (file.exists(xdir)) {setwd(file.path(xdir,"Data"))}
#    if (file.exists(sdir)) {setwd(file.path(sdir,"Progs/_install/R/Data"))}
#    #setwd("C:/users/gcook/desktop/Psyc109")
#    #setwd("X:/Data/Rtemp")
#    dbdir <- "https://www.dropbox.com/sh/8hl6ruzw5q86tpf/AACPq6F_z3uD8I98zr97cFDsa"
#}

#scriptDir <- function() {
#    fullpath = rstudioapi::getSourceEditorContext()$path
#    dir = dirname(rstudioapi::getSourceEditorContext()$path)
#    message(paste0("The current script dir is ", dir))
#    return(c(dir, fullpath))
#}

sym_path <- function(filename, set = 1, symbolic = c("J:","~/junk"), newpath = NULL) {
    if (.Platform$OS.type == "windows" & set == 1 ) {
        if (!file.exists(symbolic[1])) {
            try(system(paste0("C:/Windows/SysWOW64/subst.exe ",symbolic[1]," ",
                              dirname(filename)), intern = TRUE))
        }
        newpath = paste0(symbolic[1],"/",basename(filename))
        return(newpath)
    }
    if (.Platform$OS.type == "unix" & set == 1) {
        # make junk dir then make symbolic link to file
        if (!file.exists(symbolic[2]))    {
            dir.create(symbolic[2])
            try(system(paste0("ln -s ",filename," ",symbolic[2],"/",basename(filename))))
        }
        newpath = paste0(symbolic[2],"/",basename(filename))
        return(newpath) # may throw error
    }
    if (.Platform$OS.type == "windows" & set == 0) {
        # kill the subst drive letter
        try(system(paste0("C:/Windows/SysWOW64/subst.exe ", symbolic[1], " /D"), intern = TRUE))
    }
    if (.Platform$OS.type == "unix" & set == 0) {
        # kill the symbolic link to file
        try(system(paste0("rm ", symbolic[2],"/",basename(filename))))
        # or try(system(paste0("unlink ",macpath))
    } }

#message(paste0("The current script dir is ", scriptDir()[1]))
#scriptDir <- dirname(sys.frame(1)$ofile)
#scriptDir <- function() { dirname(sys.frame(1)$ofile) }
#message(paste0("The current script dir is ", script.dir))

######################################################
## Options
message("Editing user options...")
#options(repos="install.packages("lattice", repos="http://cran.r-project.org") # Set CRAN Mirror repository
options(scipen=999) # turn off scientific notation  # 0 = sn is on
options(digits=4)
#options(error=recover)
#https://myowelt.blogspot.com/2008/05/obtaining-same-anova-results-in-r-as-in.html
#options(contrasts=c("contr.sum","contr.poly")) for SSIII correction

# Change library location
# mylibpath = .libPaths()  # change if this is a new location
#.libPaths = (c(.libPaths(), mylibpath )) # reset .libPaths

message("Done!")
######################################################

######################################################
## --- Specifying Libraries --- ##
message("Checking for libraries...")
Sys.info()[[8]]
Rversion <- "" ; RDir <- ""; sourceDir <- ""
if(Sys.info()[[8]] %in% c("GCook","cookprojects","gcook")) {
    Rversion <- paste0(version[6],".",version[7])
    RDir <- gsub("bin.*", "library", dirname(normalizePath(file.path(R.home("bin"), "R.exe"))) )
    LibDir <- gsub("bin.*", "library", dirname(normalizePath(file.path(R.home("bin"), "R.exe"))) )
    # was "X:/Progs/_install/R/R-Portable/current/App/R-Portable/library"
    sourceDir <- gsub(pattern = "/bin/x32|/bin/x64", replacement = "", dirname(normalizePath(file.path(R.home("bin"), "R.exe"))) )
    # was paste0("X:/Progs/_install/R/R-Portable/",Rversion,"/App/R-Portable")
}

sourceDir <- gsub("/bin/x32|/bin/x64", "", dirname(normalizePath(file.path(R.home("bin"), "R.exe"))) )
           # was paste0("X:/Progs/_install/R/R-Portable/",paste0(version[6],".",version[7]),"/App/R-Portable")
#if (!file.exists(sourceDir)) {
#    sourceDir <- paste0("X:/Progs/_install/R/R-Portable/new/App/R-Portable")
#}

destDir <- sourceDir

main.packages <- c("beepr", "bibext", "boot",  "Cairo", "cairoDevice", "car", "caret", "corrplot", "colourpicker", "DT", "data.table", "devtools", "dplyr", "dygraphs", "e1071", "feather", "foreign", "gargle", "ggiraph", "ggpubr", "ggvis", "googlesheets", "haven", "httr", "htmlwidgets", "htmlTable", "janitor", "jsonlite", "kableExtra", "knittr", "lattice", "latticeExtra", "lmer4", "lubridate", "magrittr", "mailR", "nlme", "officer", "openxlsx", "outliers", "pander", "plotly", "plotrix", "rmarkdown", "Rcurl", "readr", "rms", "shiny", "shinydashboard", "shinydashboardPlus", "ssh", "sqldf", "stringr", "text2vec", "text2speech", "tidyverse", "xlsx", "XML", "XLConnect", "zip", "zoo")

#main.packages <- c("aod", "apaStyle", "apaTables", "apa", "asbio",
#                   "boot", "bootES", "broom", "BSDA", "beepr", "brms",
#                   "colorhcplot", "Cairo", "cairoDevice", "car", "caret", "compute.es",
#                   "corrplot", "clm", "curl", "copula", "colourpicker",
#                   "data.table", "datapasta", "devtools", "digest", "dplyr", "doBy", "DescTools",
#                   "dendextent", "dygraphs", "diffobj", "dgof",
#                   "e1071", "effsize", "ellipse", "exact2x2", "exactci", "ez", "ezsummary", "editR",
#                   "feather", "fgof", "foreach", "foreign", "forcats", "formatR", "FSA", "fst",
#                   "ghit", "ggvis", "gmodels", "gmailr", "gridExtra", "gridBase", "ggmap", "ggplot2",
#                   "googlesheets", "googleVis", "ggiraph", "gsl", "growthmodels", "ggpubr", "goftest",
#                   "hash", "haven", "HH", "Hmisc", "htmlTable", "htmlwidgets", "httr", "here",
#                   "imager", "installr", "janitor", "jpeg", "jsonlite", "jmv",
#                   "knitr", "kSamples",
#                   "lattice", "latticeExtra", "lawstat", "lavaan", "lexRankr", "lme4", "locfit",
#                   "logspline", "lsr", "lubridate", "LaF", "lsmeans",
#                   "maps", "mapproj", "mailR", "magick", "mgcv", "MASS", "MBESS", "memisc",
#                   "memoise", "mice", "moments",
#                   "modelr", "multcomp", "mvoutlier", "mosaic", "mgm", "nnet", "multidplyr",
#                   "mlmRev", "mediation", "metricsgraphics",
#                   "nortest", "NHPoisson", "nlme",
#                   "outliers", "openxlsx", "officeR",
#                   "party", "packrat", "pastecs", "PASWR", "PerformanceAnalytics", "plyr", "plotly",
#                   "patchwork", "pander",  "ppcor", "png", "pkgKitten", "psychometric", "purrr",
#                   "prettyR", "psych", "pwr", "profvis", "plumber", "Publish",
#                   "QuantPsyc", "qgraph",
#                   "randomForest", "remotes", "reinstallr", "RCurl", "reticulate",
#                   "RcmdrMisc", "RColorBrewer",
#                   "RSQLite", "rBokeh", "roxygen2", "rcommander",
#                   "rio", "rjson", "reshape", "rpart", "repmis", "readr", "rmarkdown", "rcdimple",
#                   "reshape2", "Rmisc", "rpf", "RSentiment", "rvest", "rdrop2", "RSiteCatalyst",
#                   "samplesize", "sentimentr", "shiny", "sjPlot", "sqldf", "stringr",
#                   "stargazer", "syuzhet", "splitstackshape", "sm", "shinythemes",
#                   "Tabulizer", "translate", "taucharts", "threejs", "truncdist",
#                   "testthat", "tidyr", "tibble", "tibbrConnector", "tidyquant", "tidycensus",
#                   "tidyverse", "tidytext", "vcd", "visreg", "wordcloud2", "WRS2",
#                   "xlsx", "XML", "XLConnect", "xtable", "xts",
#                   "validate", "zip", "zipcode", "ztable")

#install.packages("https://www.stat.auckland.ac.nz/~ihaka/software/Rnoweb/Rnoweb_1.1.tar.gz", repos=NULL, type="source")
#install.packages("X:/Progs/R/R-Portable/Rnoweb_1.1.tar.gz", repos=NULL, type="source")
#install.packages("X:/Progs/R/R-Portable/dtrace_0.1.zip", repos=NULL, type="source")

# not available (for R version 3.4.0): ScaleR , gmailR, qualtrics, RPy2
message("Any download issues?")

#download.packages("car", destDir = sourceDir, type="source")

message(paste0("\n",R.Version()$version.string,"\n"))

dl.pak <- function(pkg, destDir = sourceDir, load = FALSE, force = FALSE) {
    # download if not there
    if(!file.exists(sourceDir)){
        print("skipping") #download.packages(pkg, destDir = sourceDir, type="source")
    }
}

ipak <- function(pkg, load = FALSE, force = FALSE) {
    # force install without checking if they exist
    if (force) { install.packages(pkg, dependencies = TRUE)  }
    # install if not installed, and load
    new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
    if (length(new.pkg)) {
	install.packages(new.pkg, dependencies = TRUE)
            # versions::install.dates(new.pkg, checkpoint.date, dependencies = TRUE) # version by date
	download.packages(new.pkg, destDir = sourceDir, type="source")
	}
    if(load) {
        #message("Loading ", new.pkg, "...")
        sapply(pkg, require, character.only = TRUE) # loads all libraries if set to TRUE
    } else { print("Not set to load packages.") }
}

## --- Installing Libraries --- ##
#packageurl <- "http://cran.r-project.org/src/contrib/Archive/ggplot2/ggplot2_0.9.1.tar.gz"
#install.packages(packageurl, repos=NULL, type="source")

ipak.first <- function(pkg) {
    # install if not installed, and load
    new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
    if (length(new.pkg)) install.packages(new.pkg, dependencies = TRUE)
}

ipak.gits <- function() {
    # install if not installed, and load
    #	if(Sys.info()[[8]] %in% c("GCook","cookprojects")) {}
    #if (!"papaja" %in% installed.packages()[, "Package"])
    #    devtools::install_github("crsh/papaja")
    #if (!"multidplyr" %in% installed.packages()[, "Package"])
    #    devtools::install_github("hadley/multidplyr")
    #if (!"rio" %in% installed.packages()[, "Package"])
    #    devtools::install_github("leeper/rio")
}

# Download packages
#for (pkg in list.files(RDir)) {
#    dl.pak(pkg)
#}
message("********************** Not downloading zips")
#dl.pak(main.packages)

# get the source for those installed

# and get new ones from source
#for (pkg in list.files(sourceDir, full.names = T)) {
#    new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
    #message("Installing from source: ", new.pkg, "...")
#    if (length(new.pkg)) install.packages(new.pkg, dependencies = TRUE)
#        install.packages(new.pkg, repos = NULL, type="source")
#}

#############################################################################
#############################################################################ipak(main.packages)
#############################################################################

#pkgs.load <- function(pkg) {sapply(pkg, library, character.only = TRUE) } # if problematic, use require
load.pkgs <- function(pkg = c()) {sapply(pkg, require, character.only = TRUE) } # if problematic, use require
view <- function(object, rows = F, show = 100,...) { 
    if (is.null(dim(object)) & class(object) == "list") {
        message("Object is a list. Viewer displays last list element. Consider passing each element to view().")
        lapply(object, function(x) {DT::datatable(x, rownames = rows, options = list(pageLength = show))}) 
    } else {
        DT::datatable(object, rownames = rows, options = list(pageLength = show)) 
    }
}
gview <- function(df, rows = F, show = 100,...) { DT::datatable(df, rownames = rows, options = list(pageLength = show)) }
makedirs <- function(projdir = "", dirs = list("R","data","doc","figs","output")) {
    if(projdir == "") { message("Error: No project directory defined in function.")
    } else {
        # write the dirs in projdir #	grepl(proj, "X:/Data/TBfunc/TBfunc_Analyses/")
        for (dir in dirs) {
            if (file.exists(paste(projdir, dir, sep = "/"))) {} else { dir.create(file.path(getwd(), dir, sep = "/")) }
        }}}


## --- calling library functions --- ##
#ipak.first("versions"); library("versions") # install and/or load
#checkpoint.date = "2016-08-28"

message("made it here ****************************************************************")

#ipak(main.packages, force = F) # load or install
#devtools::install_github("crsh/papaja")
#devtools::install_github("hadley/multidplyr")

# http://lmdvr.r-forge.r-project.org/figures/figures.html
#source("http://bioconductor.org/biocLite.R")
#biocLite(c("flowCore", "flowViz", "hexbin"))

## --- for diffusion model --- ##
diffusion.packages <- c("loo", "hypergeo", "statmod", "rtdists", "pracma", "snowfall", "rlecuyer", "numDeriv", "vioplot", "RWiener", "glba")
#("loo") # For WAIC and looaic calculation
#("hypergeo") # For population plausible values
#("statmod") # Wald model
#("rtdists") # For standard model distirbution functions
#("pracma")  # For gng and stop signal robust integration
#("snowfall") # Parallel processing
#("rlecuyer") # Parallel processing
#("numDeriv") # Prior transformations
#("vioplot") # Stop signal graphs
#("glba"") # General Linear Ballistic Accumulator Models (not diffusion)
# Hydra

## --- for Bayesian model --- ##
bayes.packages <- c("BayesFactor", "rjags", "runjags")

## --- define various variables --- ##
tmp = tempfile(fileext = ".xlsx")

# negates %in%
`%ni%` <- Negate(`%in%`)

# pay

#if (Sys.info()[[8]] %in% c("GCook","cookprojects")) {
#	fastdm.file <- "C:/Users/gcook/Dropbox/Progs/FastDM/fast-dm_example_1/fast-dm.exe"
#	ipak(diffusion.packages) # load or install
#	#dl.pak(diffusion.packages)
#	dl.pak(bayes.packages)
#	ipak(bayes.packages) # load or install
#	ipak.gits()
#    message("Hydra not installed. If wanted, check around line 140.")
#    #install.packages("X:/Progs/_install/R/packages/hydra_0.9-130521.tar.gz", repos=NULL, type="source")
#}

message("Install Done!")
######################################################




######################################################
## --- Functions --- ##
message("Defining functions...")
list.as.data.frame <- function(list) {do.call(rbind.data.frame, list)}

copy.files <- function(source.dir = "", dest.dir = "", pat = ".raw", delete = F, overwrite = F) {
    list.of.files <- list.files(source.dir, pattern = pat, full.names = T)
    if (dir.exists(source.dir) & dir.exists(dest.dir)) {
            file.copy(list.of.files, dest.dir, copy.date = T, copy.mode = T,
            overwrite = overwrite) }
    else {message(paste0("One or more directory does not exist\n   ",
    source.dir, "\n   ",dest.dir))}
    message("Done copying files!")
    if (delete) {for (file in list.files(dest.dir, pattern = pat, full.names = T)) {
            if (file.exists(file)) { file.remove(paste0(source.dir,"/",basename(file)))}}
        message("Files deleted from source directory!")    }}
# copy.files("V:/Cook-Projects/E-prime/ddmface/ddmface_RawData",
# "X:/Data/ddmface/ddmface_RawData/test", ".raw", delete = F)


install.if <- function(packages = NULL) {
    `%notin%` <- Negate(`%in%`)
    pkgs = as.data.frame(installed.packages()[,c(1,3:4)])
    pkgs = pkgs[is.na(pkgs$Priority),1:2, drop = F]
    pkgs = as.vector(as.character(pkgs$Package))

    if (!is.null(packages)) {
        for (pkg in packages) {
            if (pkg %notin% pkgs) {
                install.packages(pkg)
                } else { message(paste0(pkg, " already installed")) }}}}

reinstall.packages <- function() {
    `%notin%` <- Negate(`%in%`)
    pkgs = as.data.frame(installed.packages()[,c(1,3:4)])
    pkgs = pkgs[is.na(pkgs$Priority),1:2, drop = F]
    pkgs = as.vector(as.character(pkgs$Package))

    for (pkg in pkgs) { install.packages(pkg) } }

clean.temp.dir <- function(temp.dir = 'c:/Users/gcook/AppData/Local/Temp/') {
	if (dir.exists(temp.dir)) {
		list.of.dirs <- list.files(temp.dir, pattern = 'Rtmp', full.names = T)
		for (dir in list.of.dirs) {
	    		message(paste0("Deleting: ", dir))
	    		unlink(dir, recursive = T)
		}
	} else { message('temp.dir does not exst!') }}






aggy <- function(
    batchdir = batchdir,
    analysisdir = analysisdir,
    projdir = projdir,
    lists=list(list("A","moodmodels",A.names),list("B","moodmodels",B.names),
	       list("C","moodmodels",C.names),list("D","moodmodels",D.names)), write = T)   {
    for (j in lists) {
        list <- list.files(batchdir, pattern = j[[2]]) ;
        list <- list[ !list %in% paste0(basename(projdir),j[[1]],".agg")];
        print(list)
    L <- suppressWarnings(lapply(paste0(batchdir,list), function(x) {
        tryCatch(read.table(x, header = F, col.names = j[[3]], sep = ','),
                 error = function(e) NULL) }))
    L <- do.call(rbind.data.frame, L)
    print(cat(rep(paste0("\n****",j[[2]],"****"),3))); print(head(L))
    if (write) {
    if (file.exists(paste0(analysisdir,'0.',basename(projdir),j[[1]],'.agg'))) {
        message("Deleting old agg data file...");
        file.remove(paste0(analysisdir,'0.',basename(projdir),j[[1]],'.agg')) }
    message("Writing new agg data file..."); Sys.sleep(1)
    write.csv(L, paste0(analysisdir,'0.',basename(projdir),j[[1]],'.agg'), row.names = F)
    write.csv(L, paste0(analysisdir,'0.',basename(projdir),j[[1]],'.csv'), row.names = F)
    }}}


aggy.raw <- function(pattern = "", names = "", batchdir = batchdir, drop = NULL,
                 analysisdir = analysisdir, ext = ".raw", print = T, rm.pattern = "9999") {
    if (print) {
        message("batchdir: ",batchdir); message("analysisdir: ",analysisdir)
        message("******************************")
    }
    if (pattern != "") { #& !is.null(analysisdir) ) {
        l = list.files(batchdir, pattern = pattern, full.names = T);
#        l = l[lapply(l,function(x) file.size(x) > 0) == T ] # if file size > 0
#	l = l[lapply(l, function(x) file.info(x)[["size"]] > 0]
	l = l[ file.info(l)[["size"]] > 0]
        l = l[lapply(l,function(x) length(grep(ext, x, value = T))) == 1] # get only matches
	for (pat in rm.pattern) {
	    l <- l[lapply(l,function(x) length(grep(pat,x,value = FALSE))) == 0]
	}
        l <- do.call(rbind, lapply(l, read.csv, header = F))
	print(str(l))
	if (!is.null(drop)) {
		l <- l[as.numeric(as.character(l[,1])) < drop, ]
	}
        if (length(names) == length(names(l))) {
		names(l) = names
        	message("Writing new agg data file..."); Sys.sleep(1)
		write.csv(l, paste0(analysisdir,"0.",pattern,".csv"), row.names = F)
        	message(paste0("Saved: ",analysisdir,"0.",pattern,".csv"))
        } else {
		message("Column names are not the same length.")
	}
        #print(head(l))
    } else {   message("No file pattern or 'analysisdir' not specified.")    }
	message("Done!")
    return(l)}


#aggy(batchdir, analysisDir, projdir,
#     list(list("A","moodmodels","A.names"),list("A","moodmodels","A.names")))


aggdir <- function(pattern = "", drop = NULL, dir = "",
                     ext = ".raw", print = T, rm.pattern = "7777") {
    if (dir.exists(dir)) {
    if (pattern != "") {
        l = list.files(dir, pattern = pattern, full.names = T)
        l = l[ file.info(l)[["size"]] > 0]
        l = l[lapply(l,function(x) length(grep(ext, x, value = T))) == 1]

    for (pat in rm.pattern) {
	    l <- l[lapply(l,function(x) length(grep(pat,x, value = F))) == 0]
	}
    l <- do.call(rbind, lapply(l, read.csv, header = F))

	if (!is.null(drop)) {
		l <- l[as.numeric(as.character(l[,1])) < drop, ]
	}
    write.csv(l, paste0(dir,"/0.",pattern,".csv"), row.names = F)
    message("Done!")
    return(l)}
    }
}


countSpaces <- function(s) { sapply(gregexpr(" ", s), function(p) { sum(p >= 0) } ) }

is.recalled <- function(studydf, recalldf, word = "Word",
                         recalledlist = "Recalled", drop = c("")) {
    df = merge(studydf, recalldf)
    matchFunc <- function(needle, haystack) grepl(needle,haystack)
    for (i in 1:nrow(df)) {
        df[i,"Acc"] <- as.integer(as.logical(
            matchFunc(df[i,word],df[i,recalledlist]))) }
    df <- df[ , !(names(df) %in% drop)] }

########################################## E-mailing functions
##########################################
##########################################
##########################################

mailit <- function(to = "gcook@CMC.edu", subject = "Subject",
                   body = ":)", from = "gcook@CMC.edu", pw = NULL, attach = NULL,
                   host = c("smtp.office365.com",587), ...) {
    for (pkg in c("mailR","rJava")) {if (pkg %ni% installed.packages()) { install.packages(pkg, dep = T) }}

    `%ni%` = Negate(`%in%`); to = tolower(trimws(to, "both")); from = tolower(trimws(from, "both"))
    if (as.logical(grep('cmc.edu|cgu.edu', from))) {host[1] = "smtp.office365.com"; host[2] = 587}
    if (as.logical(grepl('gmail.com',  from))) {host[1] = "smtp.gmail.com"; host[2] = 465}
    if (!is.null(pw)) {
        if (is.null(attach)) {
            mailR::send.mail(to = to, from = from,
                             subject = subject, body = body,
                             smtp = list(host.name = host[1], # "smtp.office365.com"  or "smtp-mail.outlook.com"
                                         port = host[2],
                                         user.name = from,
                                         passwd = pw, tls = TRUE),
                             authenticate = TRUE, send = TRUE)
            message(paste0("Message sent to ", to, "\n"))
        } else {
            attachments = get.pathlist(attach)
            mailR::send.mail(to = to, from = from,
                             subject = subject, body = body,
                             smtp = list(host.name = host[1], # "smtp.office365.com", # or smtp-mail.outlook.com
                                         port = host[2], user.name = from,
                                         passwd = pw, tls = TRUE),
                             attach.files = attachments,
                             authenticate = TRUE, send = TRUE)
            message(paste0("Message sent to ", to, "\n"))
        }
    } else { message("No password passed into function.")   }
}

mail.it.COM <- function(to   = c("gcook@CMC.edu"), 
                    from = c("gcook@CMC.edu"),
                    subject = "Hi", 
                    body = "", 
                    attach_path = NULL) {
  if (!require(RDCOMClient)) { 
  install.packages('RDCOMClient', repos = 'http://www.omegahat.net/R/') }
  
  OutApp <- RDCOMClient::COMCreate("Outlook.Application")
  ## create an email 
  outMail = OutApp$CreateItem(0)
  ## configure  email parameter 
  outMail[["To"]] = to
  outMail[["subject"]] = subject
  outMail[["body"]] = body
  
  if (!is.null(attach_path)) {
        if (file.exists(attach_path)) { outMail[["Attachments"]]$Add(attach_path) } 
  else { message(paste0("Attachment: ",attach_path, " does not exist"))  }
  }
  ## send it                     
  outMail$Send()
}  
#mail.it.COM()


get.pathlist <- function(f.list) {
    f.paths = NULL
    for (f in f.list) {
        if (file.exists(paste0(getwd(),"/",basename(f)))) {
            f.paths = unique(c(f.paths, paste0(getwd(),"/",basename(f))))
        } else {
            message("   ************Warning************\n")
            message("No such file: ",paste0(getwd(),"/",basename(f)),"\n")
            message("   ************Warning************\n")  }
        }
    return(f.paths)
}

#mailit(to = c("gcook@CMC.edu"), subject = "Subject", body = "Here is a model.", from = "gcook@CMC.edu",
#       password = "",
#       attachment = "C:/Users/gcook/Sync/Data/moodmodels/moodmodels_Analyses/moodmodels_recall.Rmd")


textit <- function(to = "9092607523@vtext.com", subject = "Message from R",
    body = "", from = "gcook@CMC.edu", password = "",
    host = "email.claremontmckenna.edu", portnum = 26) {
    if (password != "") {
    mailR::send.mail(to = to, subject = subject, body = body, from = from,
        authenticate = TRUE,
        smtp = list(host.name = host, # "smtp.office365.com", # or smtp-mail.outlook.com
            port = portnum, user.name = from, passwd = password, tls = TRUE))
    message(paste0("Message text to ", to))
    } else {
        message("No password set.")
    }}
#textit(to = "9092607523@vtext.com", subject = "Subject", body = "Here is a model.", from = "gcook@CMC.edu", password = "")

outlook.quick <- function(to = "gcook@CMC.edu", subject = "", body = "",
    attachment = "", from = "gcook@CMC.edu", table = "n") {
    if ("RDCOMClient" %ni% installed.packages()) {
        #install.packages("RDCOMClient", repos = "http://www.omegahat.net/R")
        library(devtools); devtools::install_github("omegahat/RDCOMClient")}
    OutApp <- COMCreate("Outlook.Application");
    for (email in unique(to)) {
        outMail = OutApp$CreateItem(0)
        outMail[["To"]] = email; outMail[["subject"]] = subject; outMail[["body"]] = body
        if (file.exists(attachment)) {  outMail[["Attachments"]]$Add(attachment)  }
        try(outMail$Send())
        message(paste0("Sending message to: ",to," - ", subject,"\n"))
        outMail = ""    }
#    if (table = "y") {
#        pander::panderOptions('table.split.table', Inf)
#        outMail[["body"]] = paste("Hello!", "", "The below summarises xxx:",
#            pander::pandoc.table.return(data.frame(V1 = 1:5, V2 = LETTERS[1:5])), sep = "\n")
#    } else {outMail[["body"]] = body }
}
#outlook.quick(c("gcook@CMC.edu; cook.gabriel@protonmail.com"), "Hey", "what's up", email.attachment)

outlook.grades <- function(x, to = "gcook@CMC.edu", from = "gcook@CMC.edu",
    subject = "Hey", body = "", attachment = "", name = "", grade = "") {
    if ("RDCOMClient" %ni% installed.packages()) {
        #install.packages("RDCOMClient", repos = "http://www.omegahat.net/R")
        library(devtools); devtools::install_github("omegahat/RDCOMClient")}
    df = as.data.frame(x); OutApp <- COMCreate("Outlook.Application");
    for (row in 1:nrow(df)) {
        outMail = OutApp$CreateItem(0)
        recipient.name <- df[row, name]; recipient.grade <- df[row, grade]
        recipient.email <- df[row, to] ; outMail[["To"]] = recipient.email
        outMail[["subject"]] = subject ; outMail[["body"]] = body
        if (file.exists(attachment)) {  outMail[["Attachments"]]$Add(attachment)  }
        try(outMail$Send())
        message(paste0("Sending message to: ", recipient.email," - ", subject,"\n"))
        outMail = ""    }}
#email.attachment = "G:/Sync/Courses/CMCStats/0.Curr/0.exams/2018/2018-PSYC-109-Grades.docx"
#outlook.grades(DF, to = "dummy.email", #"Student.Email"
#               from = "gcook@CMC.edu",
#               subject = "subject, subject",
#               body = "body body body",
#               name = "Name.First", grade = "Exam1",
#               attachment = "G:/Sync/Courses/CMCStats/0.Curr/0.exams/2018/2018-PSYC-109-Grades.docx"
#               )

#To embed table within the body of the email:
outlook.table <- function(to = "gcook@CMC.edu", from = "gcook@CMC.edu",
    subject = "Subject", body = "message body", attachment = "", table = "n") {
    #OutApp = "";
    OutApp <- COMCreate("Outlook.Application"); # outMail = OutApp$CreateItem(0)
    outMail = OutApp$CreateItem(0)
    outMail[["To"]] = to
    outMail[["subject"]] = subject ; #outMail[["body"]] = body
    if (file.exists(attachment)) {  outMail[["Attachments"]]$Add(attachment)  }
    pander::panderOptions('table.split.table', Inf)
    outMail[["body"]] = paste("Hello!", "", "The below summarises xxx:",
    pander::pandoc.table.return(data.frame(V1 = 1:5, V2 = LETTERS[1:5])), sep = "\n")
    #try(outMail$Send())
    message(paste0("Sending message to: ", recipient.email," - ", subject,"\n"))
    outMail = ""
    }

dollar.to.numeric <- function(x) {  as.numeric(gsub("\\$", "", x))  }
numeric.to.dollar <- function(x) {  as.character(paste0("$",x))  }


decimal <-         function(x, dec = 2) {format(round(x, dec), nsmall = dec)}
#specify_decimal <- function(x, dec) trimws(format(round(x, dec), nsmall = dec))

char.match <- function(a, b) {    as.numeric(adist(a,b)/nchar(a))  }

toupper.all <- function(df) {data.frame(lapply(df, function(x) {
    ifelse(is.numeric(x), return(x), return(toupper(x))) }))}

rtcheck <- function(df, rt = "RT", longrt = 5000 , shortrt = 1000,
                    bins = c(5000,4500,4000,3500,3000,2750,2500,2250,2000,1500,1000)) {
    bins = unique(c(longrt,bins,shortrt))
    df = as.data.frame(df); x = df[[rt]]
    for (time in bins) {
        rt = length(which(x > time)) / length(df[[rt]]) #dim(df)[1]
    message(paste0("RTs over ",time," ms: ", round(rt,3)*100,"%"))
    }
}

cleanup <- function(file.name = NULL) {
    if (file.exists(paste0(getwd(), "/",gsub(" ","_",file.name)," ",model,".R"))) file.remove(paste0(getwd(), "/",gsub(" ","_",file.name)," ",model,".R"))
    #if (file.exists(paste0(getwd(), "/",gsub(" ","_",file.name),"_",model,".R"))) file.remove(paste0(getwd(), "/",gsub(" ","_",file.name),"_",model,".R"))
    #if (file.exists(paste0(getwd(), "/",gsub(" ","_",file.name),"_",model,".spin.R"))) file.remove(paste0(getwd(), "/",gsub(" ","_",file.name),"_",model,".spin.R"))

    if (file.exists(paste0(getwd(), "/",gsub(" ","_",file.name),".spin.R"))) file.remove(paste0(getwd(), "/",gsub(" ","_",file.name),".spin.R"))
    if (file.exists(paste0(getwd(), "/",gsub(" ","_",file.name),".spin.Rmd"))) file.remove(paste0(getwd(), "/",gsub(" ","_",file.name),".spin.Rmd"))

    if (file.exists(paste0(getwd(), "/",gsub(" ","_",file.name)," ",model,".spin.Rmd"))) file.remove(paste0(getwd(), "/",gsub(" ","_",file.name)," ",model,".spin.Rmd"))
    if (file.exists(paste0(getwd(), "/",gsub(" ","_",file.name),"_",model,".spin.Rmd"))) file.remove(paste0(getwd(), "/",gsub(" ","_",file.name),"_",model,".spin.Rmd"))
    if (is.null(file.name)) message("File name not specified.")
}

########################################## Path and Stats functions
dpath <- function(x = "C:/Users/gcook/Sync/Data/"){
    x = x ; setwd(x); cat("Working Directory is:",getwd()); return(x) }
#dpath()
mdn.ci.boot <- function(x, conf = 0.95) {
    if (!require(boot)) {install.packages("boot")}
    m = na.omit(median(x))
    b = boot::boot(x,function(x,i) median(x[i]), R = 10000)
    bci = boot::boot.ci(b, conf = conf, type = c("norm", "basic" ,"perc", "bca"))
    hist(b$t[,1], col = "darkgray", main = "Histogram of Bootstrapped Medians", xlab = "")
    return(list(Median = m, CI = bci))
}
mean.ci.boot <- function(x, conf = 0.95) {
    if (!require(boot)) { install.packages("boot")}
    m = na.omit(mean(x))
    b = boot::boot(x,function(x,i) mean(x[i]), R = 10000)
    bci <- boot::boot.ci(b, conf = conf, type = c("norm", "basic" ,"perc", "bca"))
    hist(b$t[,1], col = "darkgray", main = "Histogram of Bootstrapped Means", xlab = "")
    return(list(Mean = m, CI = bci))
}

biserial.cor.new = function (x, y, use = c("all.obs", "complete.obs"), level = 1) {
    if (!is.numeric(x))
        stop("'x' must be a numeric variable.\n")
    y <- as.factor(y)
    if (length(levs <- levels(y)) > 2)
        stop("'y' must be a dichotomous variable.\n")
    if (length(x) != length(y))
        stop("'x' and 'y' do not have the same length")
    use <- match.arg(use)
    if (use == "complete.obs") {
        cc.ind <- complete.cases(x, y)
        x <- x[cc.ind]
        y <- y[cc.ind]
    }
    ind <- y == levs[level]
    diff.mu <- mean(x[ind]) - mean(x[!ind])
    prob <- mean(ind)
    diff.mu * sqrt(prob * (1 - prob))/sd.pop(x)
}

# split data frame into multiple files based on variable (breaks out into list)
split.to.files <- function(list, sep= ",", ext = ".csv", dir = "ddmdata", row.names = F, col.names= F) {
    dir.create(dir);
    lapply(1:length(list), function(i) write.table(list[[i]], sep = sep,
                                                   file = paste(dir,paste0(names(list[i]),ext), sep = "/"),
                                                   row.names = row.names, col.names = col.names))  }

#st.err <- function(x) { sd(x)/sqrt(length(x))  }

## Summarizes data.
breakdown.old <- function(data, formula, trim = .1) {
    dep = c("dplyr", "DescTools"); pkgs = dep[!(dep %in% installed.packages()[,"Package"])]
    if(length(pkgs)) install.packages(pkgs, dep = T)
     
    group = NULL
    formula = deparse(formula)
    formula = gsub(" ", "", formula)
    x = stringr::str_split_fixed(formula, "~", 2)[[1]]
    grps = stringr::str_split_fixed(formula, "~", 2)[[2]]
# cannot get to pass more than 1 group from formula
    #  group = gsub("\\+", ",", grps)
    #  group = deparse(substitute(group))
    group = unlist(stringr::str_split_fixed(grps, "\\+", 1+stringr::str_count(grps, "\\+")))
        
    data = as.data.frame(data) # turn into data frame
    if (is.null(group)) { data$var = "var"; group = "var" ; x = "data"}
    if (!is.null(x)) 
        
        data %>% 
        dplyr::group_by(.data[[group]]) %>%
        dplyr::summarise(
            n = dplyr::n(), #length(na.omit(.data[[x]])),
            mean = mean(.data[[x]], na.rm = T),
            mean.trim = mean(DescTools::Trim(.data[[x]], na.rm = T, trim = trim)),
            mdn = median(.data[[x]], na.rm = T),
            sd = sd(.data[[x]], na.rm = T),
            se = sd(.data[[x]], na.rm = T) / sqrt(length(na.omit(.data[[x]]))),
            skew = moments::skewness(.data[[x]], na.rm = T),
            kurt = moments::kurtosis(.data[[x]], na.rm = T),
            min = min(.data[[x]], na.rm = T),
            max = max(.data[[x]], na.rm = T),
            mad = mad(.data[[x]], na.rm = T)) %>%
        dplyr::mutate(ci.95.u = se - qt(1 - (0.05 / 2), n - 1) * se,
                      ci.95.l = se + qt(1 - (0.05 / 2), n - 1) * se
        )
} ; means.old <- breakdown.old

means <- function(data, 
                  x = NULL, by = NULL, filter = NULL, trim = .1) {
  # summarizes a data frame
  # dependent packages
  dep = c("dplyr", "DescTools", "magrittr"); pkgs = dep[!(dep %in% installed.packages()[,"Package"])]
  if(length(pkgs)) install.packages(pkgs, dep = T)
  
  #dplyr::select_(data, as.name(x))
  # manipulate the data frame
  if (is.data.frame(data)) {
    
    data = data %>% 
      dplyr::group_by_at(by) %>%
      dplyr::summarise(
        n = dplyr::n(),
        mean = mean(.data[[x]], na.rm = T),
        mean.trim = mean(DescTools::Trim(.data[[x]], trim = trim)),
        mdn = median(.data[[x]], na.rm = T),
        sum = sum(.data[[x]], na.rm = T), 
        sd = sd(.data[[x]], na.rm = T),
        se = sd(.data[[x]], na.rm = T) / sqrt(length(na.omit(.data[[x]]))),
        skew = moments::skewness(.data[[x]], na.rm = T),
        kurt = moments::kurtosis(.data[[x]], na.rm = T),
        min = min(.data[[x]], na.rm = T),
        max = max(.data[[x]], na.rm = T),
        mad = mad(.data[[x]], na.rm = T)
      )
  }
  if (is.vector(data)) {
    data = data.frame(x = data, var = gsub(".*\\$", "", deparse(substitute(D$V1))))
    
    data = data %>% 
      dplyr::group_by(var) %>%
      dplyr::summarise(
        n = dplyr::n(),
        mean = mean(x, na.rm = T),
        mean.trim = mean(DescTools::Trim(x, trim = trim)),
        mdn = median(x, na.rm = T),
        sum = sum(x, na.rm = T), 
        sd = sd(x, na.rm = T),
        se = sd(x, na.rm = T) / sqrt(length(na.omit(x) ) ),
        skew = moments::skewness(x, na.rm = T),
        kurt = moments::kurtosis(x, na.rm = T),
        min = min(x, na.rm = T),
        max = max(x, na.rm = T),
        mad = mad(x, na.rm = T)
      )
  }
  return(data)
}
 

## Gives count, mean, standard deviation, standard error of the mean, and confidence interval (default 95%).
##   data: a data frame.
##   measurevar: the name of a column that contains the variable to be summariezed
##   groupvars: a vector containing names of columns that contain grouping variables
##   na.rm: a boolean that indicates whether to ignore NA's
##   conf.interval: the percent range of the confidence interval (default is 95%)
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
    library(plyr)

    # New version of length which can handle NA's: if na.rm==T, don't count them
    length2 <- function (x, na.rm=FALSE) {
        if (na.rm) sum(!is.na(x))
        else       length(x)
    }

    # This does the summary. For each group's data frame, return a vector with
    # N, mean, and sd
    datac <- plyr::ddply(data, groupvars, .drop=.drop,
      .fun = function(xx, col) {
        c(N    = length2(xx[[col]], na.rm=na.rm),
          mean = mean   (xx[[col]], na.rm=na.rm),
          sd   = sd     (xx[[col]], na.rm=na.rm)
        )
      },
      measurevar
    )

    # Rename the "mean" column
    datac <- rename(datac, c("mean" = measurevar))

    datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean

    # Confidence interval multiplier for standard error
    # Calculate t-statistic for confidence interval:
    # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
    ciMult <- qt(conf.interval/2 + .5, datac$N-1)
    datac$ci <- datac$se * ciMult

    return(datac)
}

#create a descriptives function
stats <- function(x) (c(N = length(x), Mean = mean(x), SD = sd(x), SEM = sd(x)/sqrt(length(x)) ))

# google doc files
getClassData <- function(filename = NULL, sheet = "Sheet1", DropBoxUserId = "6036547") {
    # reads in an xlsx file from a dropbox location; currently my public folder
    if(is.null(filename)) { message("/nOoops! No file specified.")
    } else {
        library(repmis)
        DropBox.url <- paste0("https://dl.dropboxusercontent.com/u/",DropBoxUserId,"/",filename)
        df = repmis::source_XlsxData(paste0(DropBox.url, "?raw=1"), sheet = sheet)
        return(df)
    }}

download.ClassData <- function(filenames = "Psyc109_2016.xlsx", location = getwd()) {
    if(is.null(filenames)) {
        message("Error: 'filenames' argument is not specfied in function.")
    } else {
        download.file(url = paste0("https://dl.dropboxusercontent.com/u/6036547/", filenames),
                      destfile = paste0(location, "/", filenames), mode = "wb")
    }}

z_getClassData <- function(filename = "dontdelete.xlsx", sheet = "Sheet1", DropBoxUserId = "6036547") {
    # reads in an xlsx file from a dropbox location; currently my public folder
    library(repmis)
    DropBox.url <- paste0("https://dl.dropboxusercontent.com/u/",DropBoxUserId,"/",filename)
    df <- repmis::source_XlsxData(paste0(DropBox.url, "?raw=1"), sheet = sheet)
    if(is.null(df)) { message("/nOoops! Incorrect file specified.") }
    return(df)}

# probability and area demo
prob.iq <- function() {
    if (rstudio_is_available() & require(manipulate)) {
        manipulate(xpnorm(score, 100, 15, verbose=verbose),
                   score = slider(50,170),
                   verbose = checkbox(TRUE, label="Verbose Output"))}}
prob.z <- function() {
    if (rstudio_is_available() & require(manipulate)) {
        manipulate(xpnorm(score, 0, 1, verbose=verbose),
                   score = slider(0,1),
                   verbose = checkbox(TRUE, label="Verbose Output"))}}

# examining data
lookie <- function(dataframe) {
    message("Dimensions"); print(dim(dataframe));
    message("Total NAs"); print(sum(is.na(dataframe)))
    message("Summary"); print(summary(dataframe));
    print(head(dataframe))}

var2string <- function(var) {
    # deparse and substitute the name of the variable to a string
    deparse(substitute(var))}

charToFactor <- function(x) {
  if (is.data.frame(x)) {
      fact = names(x)[sapply(x, is.character)]
      x[,fact] = lapply(x[,fact], factor)
  }
  if (is.vector(x)) { x = as.factor(x)  }
  return(x)  
}

transformer <- function(dataframe, vars, fun = NULL, prefix = "", suffix = "", sep = "") {
    if(!is.null(fun)) {
        message("Adding transformed variables")
        dataframe[, paste0(prefix, vars, suffix)] <-
            lapply(dataframe[, vars], fun) }
    else {
        message("Renaming variables")
        names(dataframe) = paste(prefix, names(dataframe), suffix, sep = sep)
    }
    return(dataframe) }       # vars can be a vector
#Ex: data = as.data.frame(matrix(abs(rnorm(20)), 10))
#Ex: data = transformer(data, c("V1", "V2"), fun = log, prefix = "pre_", suffix = "_suff")
#Ex: data = transformer(data, c("V1", "V2"), prefix = "pre_" , suffix = "_suff")

# z.test
z.test <- function(data = NULL, xbar = NULL, null.mu = NULL, sigma = NULL, n = NULL, two.tailed = T) {
    # if (missing(data)) | (missing(null.mu)) | (missing(sigma)) {
    #         return(message("object '", substitute(data), "' not previously defined") ) }
    if (is.null(null.mu)) {
        return(message("Error: missing null.mu argument") ) }
    if (is.null(sigma)) {
        return(message("Error: missing sigma argument") ) }
    if (!is.null(data)) {
        if (!is.null(n)) {
            return(message("Error: n should not be included when using data argument")) }
        else {
            data = na.omit(data); xbar = mean(data); n = length(data)
        }}

    z.val = (xbar - null.mu)/(sigma/sqrt(n)); z.val = abs(z.val)

    z.p = 2*pnorm(z.val, lower.tail = F) ; if (two.tailed == F){z.p = z.p/2}
    options(digits = 4)
    report.df = as.data.frame(list(method = "One sample z-test (two-tailed)", mean = round(xbar, 3),
                                   mu = null.mu, diff = round(xbar - null.mu, 3), se = round(sigma/sqrt(n), 3),
                                   z = round(z.val, 4), p.value = z.p, n = n  ))
    #options(digits = 4)
    return(report.df)
}
# z.test(data = c(4,5,6,7,8,9), null.mu = 5, sigma = 15)

t2r <- function(t.object) {
    # take t-value and convert into r and r2
    t.val = round(t.object$statistic[[1]], 3) ; t.p = round(t.object$p.value, 3)
    #if(t.p < .05) { t.p = paste0(t.p, " *") }
    t.df = round(t.object$parameter[[1]], 3)
    t.r = round((sqrt(t.val^2/(t.val^2 + t.df))),3) ; t.r2 = round(t.r^2, 3)
    #        x = cat(t.object$method, "/n")
    #        print(paste0(x, "t = ", t.val, "   df = ", t.df,
    #                     "   p.value = ", t.p, "   r = ", t.r, "   r2 = ", t.r2))
    #print(x)
    report.df = as.data.frame(list(t = t.val, df = t.df, p.value = t.p, r = t.r, r2 = t.r2))
    #        report.df = as.data.frame(report)
    return(report.df)
}

#    fix
t.broom <- function(dataframe, var1, var2 = NULL, type = "one")  {
    library(broom)
    if(type == "one")
        t <- broom::tidy(with(dataframe, t.test(var1, mu = 0)))
    if(type == "i")
        t <- broom::tidy(with(dataframe, t.test(var1 ~ var2, paired = FALSE)))
    if(type == "p")
        t <- broom::tidy(with(dataframe, t.test(var1, var2, paired = TRUE)))
    return(t)
}

cohens.d.one.sample <- function(x, mu, sigma = NULL){
    if (is.null(sigma))  {  # if sigma is not provided
        sigma = sd(x) } # calculate estimate
    d = abs( (mean(x) - mu) / sigma ) # cohen's d
    return(d) # return the value of d
}

#detachAllPackages <- function() {
#	basic.packages <- c("package:stats","package:graphics","package:grDevices","package:utils","package:datasets","package:methods","package:base")
#	package.list <- search()[ifelse(unlist(gregexpr("package:",search()))==1,TRUE,FALSE)]
#	package.list <- setdiff(package.list,basic.packages)
#	if (length(package.list)>0)  for (package in package.list) detach(package, character.only=TRUE)
#} #detachAllPackages()

# move back n parent folders.
backdir <- function(bw = 1, reset = NULL) {
    # changes the working directory by moving up
    init <- getwd(); print(init)
    # go back n number of times
    if (!is.null(bw)) {
        for (n in 1:bw) {
            setwd('..') # set get the new dir
            newdir <- getwd() # get the new dir
        }
        #print(newdir)
    }
    if (reset == TRUE) {
        setwd(init)
    }
    return(list(newdir = newdir, init = init))
} # backdir(2, TRUE)

message("\nDone!")

#graphs
my.panel <- function(..., box.ratio) {
 panel.violin(..., col = 'grey', varwidth = FALSE, box.ratio = box.ratio)
 panel.bwplot(..., col = 'grey', cex = 0.9, pch = '|', fill = 'cyan', box.ratio = .25)
}



#sound
mp3towav <- function(dir = NULL) {
    if (is.null(dir))  dir <- dirname(file.choose()) # select file in directory
    for (song in list.files(dir)) {
        song <- paste0(dir,"/",song)
        song.dir = dirname(song)
        song.ext <- tolower(tools::file_ext(song))
        if (song.ext == "mp3") {
            song.file = tuneR::readMP3(song)
            new.name = paste0(as.character(gsub(".mp3.*", "",song)),".wav", sep = "")
            tuneR::writeWave(song.file,new.name, extensible=FALSE)
       #        tuneR::savewav(song.file, f = 22050, file=new.name,rescale=c(-1500,1500))
            if (file.exists(new.name)) {
                message(paste0("File Written:\n  ",new.name))
            } else {
                message(paste0("Error writing:\n  ",new.name))
            }
        } else {
        message("Skipped: Not an mp3 file")
        }
    }
}

######################################################

######################################################
# Setting up Python
message("Setting Python PATH...")
PyPath = "G:/DropBox/Progs/Python/Dist/python-2.7.10/;G:/DropBox/Progs/Python/Dist/python-2.7.10/lib/site-packages/;G:/DropBox/Progs/Python/Dist/python-2.7.10/Scripts/;"
#'Sys.setenv(PATH = paste("/home/username/anaconda/bin", Sys.getenv("PATH"), sep=":"))'
# or 'Sys.setenv(PATH = paste(PyPath, Sys.getenv("PATH"), sep=":"))'
# or Sys.setenv(PATH = paste(PyPath, Sys.getenv("PATH"), sep=":"))

message("The file was read successfully!")


months <- c("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec")
month.abb <- function(x) {
	# converts a vector of numeric values for months (e.g., 1- 12) to an abbreviated vector
	months <- c("Jan","Feb","Mar", "Apr","May","Jun", "Jul","Aug","Sep", "Oct","Nov","Dec")
	return (months[x]) }

diff.days <- function(start, end) {
    x = as.numeric(as.Date(start) - as.Date(end))
    #message(paste0("Time difference of ",x, " days"))
    return(x)
}
flattenCorrMatrix <- function(cormat, pmat) {
  ut <- upper.tri(cormat)
  data.frame(
    row = rownames(cormat)[row(cormat)[ut]],
    column = rownames(cormat)[col(cormat)[ut]],
    cor = (cormat)[ut],
    p = pmat[ut]
    )
}

# some simple date format functions
dates <- function(d = 3) {
        #use Sys.Date to obtain the current date year, month, or day
        a = stringr::str_split_fixed(Sys.Date(),"-",3)[,1]
        b = paste0(stringr::str_split_fixed(Sys.Date(),"-",3)[,1],"-",
                 stringr::str_split_fixed(Sys.Date(),"-",3)[,2])
        c =  as.character(Sys.Date())
        x <- ifelse(d == 1, a, ifelse(d == 2, b, c)); return(x)
}

year_to_decade <- function(x) {
  return(round(x / 10) * 10)
}

yyyy = function(
    # make a list of years from x to y repeating how many. Default
    # returns a character vector of each year repeated 12 times
    d = 3,
    from = as.numeric(stringr::str_split_fixed(Sys.Date(),"-",3)[,1]),
    to = 2000, times = 1, each = 12) {
    yyyy <- as.character(rep(seq(from=from, to=to),
                             times=times, length.out=NA, each=each))
    mm <- rep(seq(from=1,to=12),times=length(yyyy)/12,length.out=NA,each=1)
    yyyy.mm <- paste0(yyyy,"-",ifelse(mm < 10,paste0("0",mm),mm))
    yyyy.mm.dd <- paste0(yyyy.mm,"-01")
    ifelse(d==1, return(yyyy), ifelse(d==2,return(yyyy.mm),
                 ifelse(d==3,return(yyyy.mm.dd), NA)))
}
winsor1 <- function(x, fraction = .05) {
   if (length(fraction) != 1 || fraction < 0 ||
         fraction > 0.5) {
      stop("bad value for 'fraction'")
   }
   lim <- quantile(x, probs = c(fraction, 1 - fraction))
   x[ x < lim[1] ] <- lim[1]
   x[ x > lim[2] ] <- lim[2]
   x
}

winsor2 <- function(x, multiple = 3) {
   if (length(multiple) != 1 || multiple <= 0) {
      stop("bad value for 'multiple'")
   }
   med <- median(x)
   y <- x - med
   sc <- mad(y, center = 0) * multiple
   y[ y > sc ] <- sc
   y[ y < -sc ] <- -sc
   y + med
}

grep.vec <- function(x, needle = ".csv", exists = 1) {
    # removes items from vector containg string
    if (is.vector(x)) {
    x[ lapply( tolower(x),
        function(x)length(grep(needle,x,value = F))) == exists]
    } else { message(paste0("is not a list"))}}

inStr  <- function(haystack, needle,...) { grepl(needle, haystack,...) }
inStrs <- function(haystack, needle,...) {
  for (n in needle) { is(grepl(n, haystack,...)) }}

strReplace <- function(haystack, needle, replace,...) {
  gsub(needle, replace, haystack,...)}

forStrInStrs  <- function(haystack, needles, repstr,...) {
    for (needle in needles) {
      haystack = ifelse(inStr(haystack, needle), repstr, haystack) }
  return(haystack)
}

inStrPos <- function(needle, strings, FUN = regexpr,...) {
  if (length(strings) == 1) {
    x = as.numeric(sapply(needle, FUN, strings, ignore.case=T,...))
    } else {
      x = sapply(needle, FUN, strings, ignore.case=T,...)[,1]
      x = ifelse(x > 0, x, 0)
    }
  return(x)
}
#inStrPos(c("z"), c("az","tt"), regexpr)

# deterine whether a strings characters are in a string pattern (default search for letters) 
string.has <- function(v, pattern = letters) {
  if (!is.null(v)) {
  unlist(lapply(v, FUN = function(x) { # for each string
      l = unlist(lapply(x, FUN = function(x) { strsplit(x, "") })) # get each letter
      T %in% unlist(lapply(l, FUN = function(x) { grepl(x, pattern) } )) # does letter exist
    }))
}}



anew <- readxl::read_excel("C:/Users/gcook/Sync/Data/valjosl/stim/ANEW.XLS")
dict <- tolower(anew$word)

recall_count <- function(haystack, dict) {
    wordcount = 0
    spaces = length(gregexpr(" ", haystack)[[1]])
    recallstring = stringr::str_split_fixed(haystack, " ", spaces)
    for (word in recallstring) {
        if (word %in% dict) { wordcount = wordcount + 1 }}
    return(wordcount)}
#recall_count(haystack = "happy sad anger go wisdom  hate hat asflj", dictionary)
#sapply(d$recalled.list, function(x) recall_count(x, dictionary))

match.prob <- function(needle, haystack) {
    spaces = length(gregexpr(" ", haystack)[[1]])
    recallstring = stringr::str_split_fixed(haystack, " ", spaces)
    sim = NULL ; sim.vals = NULL
    for (word in recallstring) {
        sim.val = 1 - adist(needle, word) / nchar(as.character(needle))
        sim.vals = append(sim.vals, sim.val)
        sim = max(sim.vals)
    }
    return(sim)}

match.prob.over.rows <- function(dataframe, needle, haystack) {
    apply(dataframe, 1, function(x) match.prob(x[needle],x[haystack]))}

match.strict <- function(needle, haystack, threshold = .9) {
    spaces = length(gregexpr(" ", haystack)[[1]])
    recallstring = stringr::str_split_fixed(haystack, " ", spaces)
    sim = 0
    for (word in recallstring) {
        sim_val = 1 - adist(needle, word) / nchar(as.character(needle))
        sim = as.numeric(ifelse(sim_val >= threshold, 1, break))
    }
    return(sim)
}

match.strict.over.rows <- function(dataframe, needle, haystack, threshold) {
    apply(dataframe, 1, function(x) match.strict(x[needle],x[haystack], threshold))}

gsub.parens <- function(x) {gsub("[\\(\\)]", "", regmatches(x, gregexpr("\\(.*?\\)", j))[[1]])}

file.date8 <- function(x) { as.numeric(substring(gsub("[space -]","",file.info(x)$mtime), 1, 8)) }

get.dir <- function(rep = NULL, sep = "") {
    a = gsub(sub(".*/", "", tools::file_path_sans_ext(rstudioapi::getActiveDocumentContext()$path)),"",
         sub(".Rmd", "", tools::file_path_sans_ext(rstudioapi::getActiveDocumentContext()$path)))
    a = gsub("/r/",sep, a)
    if (!is.null(rep)) { a = gsub("/r/",sep, a) }
    return(a)
}

is.even <- function(x) { (x %% 2) == 0 } # determines whether value is even

tblFun <- function(x){
    tbl <- table(x)
    res <- cbind(tbl,round(prop.table(tbl)*100,2))
    colnames(res) <- c('Count','Percentage')
    res
}

getPercentages <- function(df, colName) {
  df.cnt <- df %>% select({{colName}}) %>%
    table() %>%
    as.data.frame() %>%
    rename({{colName}} :=1, Freq=2) %>%
    mutate(Perc=100*Freq/sum(Freq))
}

means1 <- function(data, y = formula()) {
  # note: if summarizing a single variable, use var ~ var, or formula will fail 
  agg = aggregate(y, data = data, 
          FUN = function(x) c(mean = round(mean(na.omit(as.numeric(x))), 4), 
                              se   = round(sd(as.numeric(x))/sqrt(sum(!is.na(as.numeric(x)))), 4),
#se   = round(plotrix::std.error(na.omit(as.numeric(x))), 4),
                              mdn  = round(median(na.omit(as.numeric(x))), 4),
                              min  = round(min(na.omit(as.numeric(x))), 4), 
                              max  = round(max(na.omit(as.numeric(x))), 4),
                              n    = length(na.omit(as.numeric(x))),
                              skew = round(e1071::skewness(na.omit(as.numeric(x))), 4)
                              )
  )
  
  df <- data.frame(mean = agg[[as.character(y)[2]]][,1],  
                   se   = agg[[as.character(y)[2]]][,2],
                   mdn  = agg[[as.character(y)[2]]][,3], 
                   min  = agg[[as.character(y)[2]]][,4], 
                   max  = agg[[as.character(y)[2]]][,5], 
                   n    = agg[[as.character(y)[2]]][,6],
                   skew = agg[[as.character(y)[2]]][,7] 
                )
  
  if (as.character(y)[[2]] != as.character(y)[[3]]) { # if there are > 1 factors in formula

      df[[as.character(y)[2]]] <- df[["mean"]]
      v.names <- names(df)
      
      # then populate with vars from formula
      fy = gsub(" ", "", as.character(y)[3])
      vars = stringr::str_split_fixed(fy, "\\+", stringr::str_count(fy, "\\+")+1)
      
      # then populate the data frame with vars from formula
      for (i in 1:dim(vars)[2]) {   df[[ vars[1,i] ]] <- agg[,i]   }
           df <- df[, c(vars[1,], v.names)] # rearrange columns
      df[[ paste0(as.character(y)[2],".z") ]] <- scale(df[[ "mean" ]])
      #print(df); 
      }
      if (as.character(y)[[2]] == as.character(y)[[3]]) {  #if there is only 1 factor in formula
          row.names(df) <- as.character(y)[[2]]  
      }
  return(df)
} #example call: means(OGT, rt ~ cond + wordtype)

mmeans <- function(data, vars= c(""), by = c("") ) {
  data.t <- data.table::data.table(data) #convert to data table
  return(as.data.frame(data.t[, lapply(.SD, mean, na.rm = T), by = by, .SDcols = vars ] ))
}

hex.red = '#FF0000'; hex.reddark = "#8B0000"; hex.redtomato = "#FF6347";
hex.green = "#008000"; hex.lawngreen = "#7CFC00"
hex.darkgray = "#A9A9A9";
hex.dodgerblue = "#1E90FF"; hex.deepskyblue = "#00BFFF"


remove.from.list <- function(x, string = "", present = 1) {  if (string != "") { 
  return(x[lapply(x,function(x) length(grep(string, x, value = T))) == present]) }}


if( file.exists('C:/Program Files/Java')) { message("Java Installed: ", list.files('C:/Program Files/Java')[1], " ... setting JAVA_HOME"); 
Sys.setenv(JAVA_HOME = paste0("C:/Program Files/Java/",list.files('C:/Program Files/Java')[1]))
 } else { message("***JAVA is not installed***") }  # for 64-bit version

names.by.pattern <- function(x, pattern, header = T, lower = T) {
  # pass file list, return nameas based on a pattern 
  for (i in 1:length(x)) {
       if (file.exists(x[[i]])) {
           if ( file.size(x[[i]]) > 1) {
               message(paste0("Reading...", x[[i]]))
               dat <- read.csv(x[[i]], sep = ",", header = header)
               if (lower == T) { 
                   names(dat) <- tolower(names(dat))  
               }
               pat.names <- names(dat)[c(grep(pattern, names(dat)))]
           }}} 
  message("Lowercase names form pattern match: ")
  print(pat.names)
  return(pat.names)
} # names.by.pattern(dat_files, "ogt")

agg.files.by.pattern <- function(x, pattern, header = T) {
  # pass file list, return data frame with columns based on pattern match
  datlist <- list()
  for (i in 1:length(x) ) {
       if (file.size(x[[i]]) > 1) {  
       message(paste0("reading...", x[[i]]))
       dat <- read.csv(x[[i]], sep = ",", header = header)
       names(dat) <- tolower(names(dat))
       datlist[[i]] <- dat[, c(grep(pattern, names(dat)))]
  }}
  d <- list.as.data.frame(datlist) 
  return(d)
} #DAT <- agg.files.by.pattern(dat_files, "ogt"); view(DAT)


agg.files.by.names <- function(x, names, header = T) {
  # pass file list, return data frame with columns based on column names
  datlist <- list()
  for (i in 1:length(x) ) {
       if (file.size(x[[i]]) > 1) {  
       message(paste0("reading...", x[[i]]))
       dat <- read.csv(x[[i]], sep = ",", header = header)
       names(dat) <- tolower(names(dat))
       datlist[[i]] <- dat[, c(names)]
  }}
  d <- list.as.data.frame(datlist) 
  return(d)
} #DAT <- agg.files.by.names(dat_files, var.names); view(DAT)



# Financials
call.option <- function(strike = 15, limit = 1.71, 
                        price = 25, contracts = 1) {
  cost = strike + limit
  gain = price - cost  # above call
  message(paste0("Upfront Cost is $",(100 * contracts * limit)))
  message(paste0("Gain per share: $",gain))
  message(paste0("Total Gain is $",(gain * (100 * contracts) ) ))
  
}

#satoshi <- function(sats = 1, btc = NULL) {
#  url <- "https://www.bitstamp.net/api/transactions/"
#  if is.null(btc) {
#      bs_data = RJSONIO::fromJSON(url) # returns a list
#      bs_df = do.call(rbind,lapply(bs_data,data.frame,stringsAsFactors=FALSE))
#      btc = as.numeric(bs_df[1,"price"])
#      sat = btc * .00000001
#      return(sat * sats)
#      #satoshi(21000)  
#}
#}

btcprem <- function() {
  wd = getwd()
  setwd("X:/Data/BTC")
  
  sheet = "Sheet1"
  xlfile = "GBTC_premium.xlsx"
  if (file.exists(xlfile)) {
      dat = xlsx::read.xlsx(xlfile, sheetIndex = sheet, header = T)
      last_premium = dat[dim(dat)[1],"Premium"]
      avg_premium = mean(dat$Premium, na.rm = T)
      }
      grayscale_bit_share = .00095012 #.00095028
      url <- "https://www.bitstamp.net/api/transactions/"
      bs_data = RJSONIO::fromJSON(url) # returns a list
      bs_df = do.call(rbind,lapply(bs_data,data.frame,stringsAsFactors=FALSE))
      btc_date = as.POSIXct(as.numeric(as.character(bs_df[1,"date"])), 
                            origin = '1970-01-01', tz = 'America/Los_Angeles')
      btc_date = paste0(as.character(btc_date), " PST")
      btc = as.numeric(bs_df[1,"price"])
      gbtc = quantmod::getQuote("GBTC")[1,"Last"]
      prem = (gbtc/grayscale_bit_share - btc)/btc * 100
      ##message(paste0(btc_date," PST ","BTC = $",btc, "; GBTC = $",gbtc," (",round(prem,2),"%/",round(avg_premium,2),"%)"))
      ##dat.new = data.frame(Date = btc_date, BTC = btc, GTBC = gbtc, Premium = prem)
      ##dat = data.frame(rbind(dat, dat.new))
  
#      if (last_premium < avg_premium) {
#    #    print("yes")
#    #    message("Issac")
#      
#      
#      # write out
#      #xlsx::write.xlsx(dat, sheetName = sheet, xlfile, row.names = F)
#

      txt = paste0("BTC = $",btc, " | GBTC = $",gbtc," | Prem = ", round(prem,2))
#      write.table(txt, "GBTC.txt", row.names = F, col.names = F)
#
#      }
      setwd(wd)
      return(prem)
}


#run
#btcprem()


###########################################################################
########################## PACKAGES #######################################
# loading and installing packages
getPackages <- function(package.list = NULL, load = FALSE, force = FALSE, get.source = F) {
    if (!is.null(package.list)) {
      # force install without checking if they exist
      if (force) { install.packages(package.list, dependencies = TRUE)  }
      # install if not installed, and load
      new.pkgs <- package.list[!(package.list %in% installed.packages()[, "Package"])]
      if (length(new.pkgs)) {
        install.packages(new.pkgs, dependencies = TRUE)
        # versions::install.dates(new.pkg, checkpoint.date, dependencies = TRUE) # version by date
      }
      if (get.source) { download.packages(new.pkgs, destDir = sourceDir, type = "source")    }
      if(load) {
        #message("Loading ", new.pkg, "...")
        sapply(package.list, require, character.only = TRUE) # loads all libraries if set to TRUE
      } else { print("Load packages if desired.") }
    }
} #;  getPackages(c("DT", "ggplot2"), load = T)
  
################################ MATH #####################################
se <- function(x) sd(x) / sqrt(length(x))     # create your own function (same as plotrix::std.error())

###########################################################################
################################ TABLES ###################################

view <- function(df, rows = F, show = 100,...) {  # set parameters
  if (!require("DT")) install.packages("DT")      # install library if not installed
  if( ( is.data.frame(df) | is.matrix(df) )) {
    DT::datatable(df, rownames = rows, options = list(pageLength = show)) # arguments passed to parameters
  } else { message("Object is not two dimensional. Likely only passing one column.") }
}

###########################################################################
################################ PLOTS ####################################
barPlot <- function(x, main = "Title", freq = T, labels = F, col = rainbow(length(table(x))), ...) {
  # create a barplot based on vector; need to convert first to a table or a prop.table
  if (freq) {
    # Absolute frequency 
    barp <- barplot(table(x), main = paste0(main, ""), col = col, ...)
    if (labels) text(barp, table(x) + 0.5, labels = table(x))
    #return(barp)
  } else {
    # Relative frequency
    barp <- barplot(prop.table(table(x)) * 100, main = paste0(main," (%)"), col = col, ...)
    if (labels) text(barp, table(x) + 0.5, labels = table(x))
    #return(barp)
  }
}
bp <- barPlot # old reference, function renamed


histPlot_col <- function(x = 1000, mean = 0, sd = 1, breaks = 100, prob = .95, 
                       col.upper = "red",
                       col.lower = "red",
                       col = "gray", ...) {
  x = rnorm(x, mean, sd)
  hx = hist(x, breaks = breaks, plot = T, ...)
  plot(hx, col = ifelse(abs(hx$breaks) > qnorm(prob, mean, sd), col.upper,
                 ifelse(abs(hx$breaks) < qnorm(1-prob, mean, sd), col.lower, col)), ...)
  return(x)
} #t <- hist_col(1000, 100, 15, prob = .99, main = "", xlab = "IQ", ylim = c(0,45))
hist_col <- histPlot_col # old reference, function renamed


# this function will produce a histogram but will clean up the xlab variable name and add the M and SE
histPlot <- function(x, col = "yellow", xlab = NULL, ylab = NULL, main = NULL,...) {
  txt = gsub("_", " ", gsub(".*\\$", "", deparse(substitute(x))))
  txt = gsub("_", " ", gsub(".*\\[,", "", txt))
  txt = gsub("]", " ", txt)
  txt = gsub('"', "", txt)
  hist(x, xlab = paste0(txt, " (n = ", length(na.omit(x)),")"), ylab = "Frequency",
       breaks = 25, col = col, 
       main = paste0("M = ", round(mean(x, na.rm = T), 2), " | ",
                     "SE = ", round(sd(x, na.rm = T) / sqrt(length(na.omit(x))), 3))
       )
}
ghist <- histPlot # old, function renamed

#############################################################################################
######################################## CLUSTER/PLOTS ######################################
# see others at https://www.gastonsanchez.com/visually-enforced/how-to/2012/10/03/Dendrograms/


############ K-MEANS ########################################################################
# kmeans clustering with a distance plot option or dimension plot with option for a factor variable

kmeansPlot <- function(df, k = 3, nstart = 25, geom = c("point", "text"), distance = F,
                    ellipse.type = c("convex", "euclid", "norm"), ellipse.level = .95,  
                    elbow.method = c("wss", "gap_stat", "silhouette"),
                    algorithm = c("Hartigan-Wong", "Lloyd", "Forgy","MacQueen"),
                    label.rectangle = F, palette = c("npg", "lancet", "jco"),
                    title = "", size = 1.5, animate = F, ...) {
  # inspired by:
  # https://uc-r.github.io/kmeans_clustering
  # https://www.datanovia.com/en/blog/k-means-clustering-visualization-in-r-step-by-step-guide/
  df = as.data.frame(df)
  dep = c("animation", "factoextra", "ggpubr")
  pkgs = dep[!(dep %in% installed.packages()[,"Package"])]
  if(length(pkgs)) install.packages(pkgs, dep = T)
  
  
  if (ellipse.type %in% c("convex", "euclid", "norm") && 
      elbow.method %in% c("wss", "gap_stat", "silhouette") &&
      algorithm %in% c("Hartigan-Wong", "Lloyd", "Forgy","MacQueen")) {
  
  # get distances for factoextra::fviz_dist()
  if (distance) {
      distance = factoextra::get_dist(df)
      factoextra::fviz_dist(distance, gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07"))
  } else {

  # identify the numeric vs. factor
  fact = NULL
  vars = names(df)[sapply(df, is.numeric)]       # get names of numeric columns
  if (T %in% sapply(df, is.character)) {         # if any are characters
      fact = names(df)[sapply(df, is.character)]
      df[fact] = lapply(df[fact], factor)        # convert to factor
  }
  if (T %in% sapply(df, is.factor)) {            # if any are characters
      fact = names(df)[sapply(df, is.factor)]    # specify the factor names
      if (length(names(df)[sapply(df, is.factor)]) > 1) {"Pass only one factor for graphing."}
  }
  # cluster
  km <- kmeans(scale(df[,vars]), k, nstart = nstart, algorithm = algorithm)  # scale the numeric vars
  # do elbow plot
  if (length(ellipse.type) == 1)  { ellipse = T } else { ellipse = F }  # ellipse if type used
  if (length(elbow.method) == 1)  { elbow   = T } else { elbow   = F }  # elbow if elbow used
  
  if (elbow) {
    factoextra::fviz_nbclust(df[,vars], kmeans, method = elbow.method)
  } else {
      # animate cluster
      if (animate) { animation::kmeans.ani(df[,vars], k) 
      } else {
      # Dimension reduction using PCA
      pca <- prcomp(df[,vars],scale = TRUE)
      
      # Coordinates of individuals
      ind.coord <- as.data.frame(factoextra::get_pca_ind(pca)$coord)
    
      # Percentage of variance explained by dimensions
      eigenvalue <- round(factoextra::get_eigenvalue(pca), 1)
      variance.percent <- eigenvalue$variance.percent
    
      # Add clusters obtained using the K-means algorithm
      ind.coord$cluster <- factor(km$cluster)
      
      if (length(algorithm) > 1) { algorithm = "Hartigan-Wong" }  # default algo
      if (length(geom)      > 1) { geom = "point" }  # default to points
      if (length(palette)   > 1) { palette= "npg" }  # default to "npg" pallete
      
      # if there is a factor column
      if (T %in% sapply(df, is.factor)) {          # if any are factors
          ind.coord[, fact] <- df[, fact ]         # add factor levels from the original data
          if (tolower(geom) == "text")  {          # if points should display text label
            p = ggpubr::ggscatter(
               data = ind.coord, x = "Dim.1", y = "Dim.2", 
               color = "cluster", palette = palette,
               label = row.names(ind.coord), label.rectangle = label.rectangle, 
               show.legend.text = F, conf.int = T,
               ellipse = ellipse, ellipse.type = ellipse.type,
               shape = fact, size = size,  legend = "right", 
               xlab = paste0("Dim 1 (", variance.percent[1], "% )" ),
               ylab = paste0("Dim 2 (", variance.percent[2], "% )" ),
               ggtheme = theme_classic() ) + ggpubr::stat_mean(
                 aes(color = cluster), size = 4) + ggtitle(title)  
          } else { # if points and no text   
            p = ggpubr::ggscatter(
               data = ind.coord, x = "Dim.1", y = "Dim.2", 
               color = "cluster", palette = palette, #label = row.names(ind.coord),
               show.legend.text = F, 
               ellipse = ellipse, ellipse.type = ellipse.type,
               shape = fact, size = size,  legend = "right", 
               xlab = paste0("Dim 1 (", variance.percent[1], "% )" ),
               ylab = paste0("Dim 2 (", variance.percent[2], "% )" ),
               ggtheme = theme_classic() ) + ggpubr::stat_mean(
                 aes(color = cluster), size = 4) + ggtitle(title)
          }
      # if there is no factor column
      } else {   
          if (tolower(geom) == "text")  { # if points should display text label
            p = ggpubr::ggscatter(
               data = ind.coord, x = "Dim.1", y = "Dim.2", 
               color = "cluster", palette = palette,
               label = row.names(ind.coord), label.rectangle = label.rectangle, 
               show.legend.text = F, conf.int = T,
               ellipse = ellipse, ellipse.type = ellipse.type,
               size = size,  legend = "right", 
               xlab = paste0("Dim 1 (", variance.percent[1], "% )" ),
               ylab = paste0("Dim 2 (", variance.percent[2], "% )" ),
               ggtheme = theme_classic() ) + ggpubr::stat_mean(
                 aes(color = cluster), size = 4) + ggtitle(title)  
          } else { # if points 
            p = ggpubr::ggscatter(
               data = ind.coord, x = "Dim.1", y = "Dim.2", 
               color = "cluster", palette = palette, #label = row.names(ind.coord),
               show.legend.text = F, 
               ellipse = ellipse, ellipse.type = ellipse.type,
               size = size,  legend = "right", 
               xlab = paste0("Dim 1 (", variance.percent[1], "% )" ),
               ylab = paste0("Dim 2 (", variance.percent[2], "% )" ),
               ggtheme = theme_classic() ) + ggpubr::stat_mean(
                 aes(color = cluster), size = 4) + ggtitle(title)
          }
      } # end factor if()
      }
  }}} else { 
    message(paste0("Recheck 'ellipse.type', 'elbow.method', and algorithm arguments. ",
                   "ellipse.type ='convex', 'euclid', 'norm'); ", 
                   "elbow.method = c('wss', 'gap_stat', 'silhouette'; ",
                   "algorithm = c('Hartigan-Wong', 'Lloyd', 'Forgy', 'MacQueen')"))}
return(list(cluster = km$cluster, km = km, plot = p))   # return the cluster  
}


############ HCLUST #########################################################################
# cluster dendograms
corPlot <- function(df, plot = "tree", method = "complete", cex = 1, 
                     num.clusters = 2, axes = F, horiz = F, main = "",
                     ylab = "", xlab = "", sub = "", drop.NA.rows = F,
                     label.offset = .01, label.size = 3.5, ...) {

  #treelist = list()
  # remove all columns with 0 sd
  df = Filter(function(x) sd(x) != 0, df)
  #df = df[, sapply(df, function(x) { sd(x, na.rm = T) != 0} )] 
  
  # remove rows with an NA in those columns
  if (drop.NA.rows) df = df[complete.cases(df), ] 
  #message(paste0("Rows: ",dim(df)[1], " Cols: ", dim(df)[2]))
  if (dim(df)[1] > 1 & dim(df)[2] > 1)  {


      x.cor = cor(as.data.frame(df))            # ensure data frame
      # scale vars first
      numCols <- sapply(df, is.numeric)         # get numeric cols
      df[numCols] <- lapply(df[numCols], scale) # scale them all
      # correlate and distcance
      x.dist   = as.dist(1 - x.cor)
      x.hclust = hclust(x.dist, method = "complete")
      x.dend   = as.dendrogram(x.hclust)  
      # plot the cluster dendogram
      if (plot == "html") htmlTable::htmlTableWidget(cor(df), ...)
      if (plot == "cormat") rquery.cormat(df, type = "full", ...)
      if (plot == "heatmap") rquery.cormat(df, graphType = "heatmap", ...)
      if (plot == "heatmap2") heatmap(cor(df), scale = "column", ...) # Use 'scale' to normalize 
      if (plot == "tree") {
          if (!horiz) {
              plot(x.hclust, cex = cex, axes = axes, main = main, 
                               ylab = ylab, xlab = xlab, sub = sub, ...)
          }
          if (horiz) {
              plot(ape::as.phylo(x.hclust), cex = cex, 
                  main = main, sub = sub, label.offset = label.offset, ...)
          }
      }
      if (plot == "color tree") { #dendextend::color_labels(x.dend, num.clusters = num.clusters, ...)
          plot(dendextend::color_labels(
          as.dendrogram(hclust(x.dist, method = "complete")), num.clusters), 
              cex = 1, axes = F, main = main, 
              ylab = "", xlab = "", sub = "", horiz = horiz)
      }
      if (plot == "cladogram") {
          plot(ape::as.phylo(x.hclust), type="cladogram", cex = cex, 
               main = main, sub = sub, label.offset = label.offset, ...)
      }
      if (plot == "unrooted") {
          plot(ape::as.phylo(x.hclust), type = "unrooted", cex = cex, 
               main = main, sub = sub, label.offset = label.offset, ...)
      }
      # not working if pairPlot is also there. Not sure why.
      #if (plot == "lower") { 
      #    ggcorrplot::ggcorrplot(cor(as.data.frame(df)), 
      #                                   hc.order = T, 
      #                                   type = "lower", #ggtheme = ggplot2::theme_minimal,
      #                 lab = T, #outline.color = "white",
      #                 title = "main", lab_size = label.size)
      #}
      if (plot == "pairmat") {
          pairPlot = GGally::ggpairs(data = df, upper = "blank",
          #diag = list(continuous = "bar"), #wrap_fn_with_params()
          diag = list(continuous = GGally::wrap("densityDiag")),
          lower = list(continuous = GGally::wrap(ggally_smooth_lm)),
          title = main)
          pairPlot
       }
       #if (plot == "lower") {lowerPlot}
       
  } else {
    message(paste0("Not enough rows or columns to correlate./n","Rows: ",dim(df)[1],
                   " Cols: ", dim(df)[2]))} 
}
cor_plot <- corPlot  # old reference, function renamed

corPlot_lower <- function(df, plot = "lower", method = "complete", 
                          scale = T, cex = 1, num.clusters = 2, axes = F, horiz = F, 
                          main = "", ylab = "", xlab = "", sub = "", 
                          drop.NA.rows = F, label.offset = .01, label.size = 3.5,...) {
  # remove all columns with 0 sd
  df = Filter(function(x) sd(x) != 0, df)
  #df = df[, sapply(df, function(x) { sd(x, na.rm = T) != 0} )] 
  
  # remove rows with an NA in those columns
  if (drop.NA.rows) df = df[complete.cases(df), ] 

  # scale vars first
  numCols <- sapply(df, is.numeric)                      # get numeric cols
  if (scale) { df[numCols] <- lapply(df[numCols], scale) # scale them all }
  if (plot == "lower") { 
          ggcorrplot::ggcorrplot(cor(as.data.frame(df)), 
                                         hc.order = T, 
                                         type = "lower", #ggtheme = ggplot2::theme_minimal,
                       lab = T, #outline.color = "white",
                       title = main, lab_size = label.size)
  }}
}
cor_plot_lower <- corPlot_lower  # old reference, function renamed

cor2clust <- function(df, # df with variables to be correlated ONLY
                      cor.use = "complete.obs",
                      cor.method = "pearson",
                      clust.method = "complete", scale = T,
                      plot.show = T, 
                      axes.show = F, title = "Distances = 1 - r",
                      var.font = 1.2, ylab = NULL, xlab = NULL, sub = NULL, ...) {

  # scale vars first
  numCols <- sapply(df, is.numeric)                      # get numeric cols
  if (scale) { df[numCols] <- lapply(df[numCols], scale) # scale them all }
  
  d = as.dist(1 - cor(df, use = cor.use, method = cor.method, ...) )
  clust = stats::hclust(d, method = clust.method)
  if (plot.show) plot(clust, main = title, axes = axes.show, cex = var.font,
#                      ylab = ylab, xlab = xlab, sub = sub, 
                      nodePar = 
                        list(lab.cex = 0.6, pch = c(NA, 19), cex = 0.7, col = "blue"),
                      horiz = TRUE, ...)
  return(d)
  }
}  

#cor2clust(df = x, var.font = 1.5, title = "AHK Usage", ylab = "", xlab = "", sub = "")

#cor2clust(df = AHK, cor.method = "kendall", 
#          var.font = 1.5, title = "AHK Usage", ylab = "", xlab = "", sub = "")


corPlot_pairs <- function(df, title = "", scale = T) {
  df = as.data.frame(df)

  # scale vars first
  numCols <- sapply(df, is.numeric)                      # get numeric cols
  if (scale) { df[numCols] <- lapply(df[numCols], scale) # scale them all }

  GGally::ggpairs(data = df,  upper = "blank",
  diag = list(continuous = GGally::wrap("densityDiag")),
  lower = list(continuous = GGally::wrap(ggally_smooth_lm)),
  title = title)
}
}
gplot_pairs <- corPlot_pairs

#################################### LIKERT SCALE ###########################################

likertPlot <- function(df, title = "", points.no.neutral = NULL, neutral.point = NULL, 
                         reverse.colors = T, reverse.scale = T, ...)  {
                sjPlot::plot_likert(df, title = title, catcount = points.no.neutral, 
                                    cat.neutral = neutral.point, 
                    reverse.colors = reverse.colors, reverse.scale = reverse.scale)
}
gplot_likert <- likertPlot


#############################################################################################
######################################## STRINGS ############################################
answer_match <- function(x = NULL, y = NULL, threshold = .5, separated = F) {
  # set threshold = 1 for exact match
  if (!is.null(x) && !is.null(y)) {
    if (separated)  {   # search multiple word answers (separated by spaces for example)
      ifelse(grepl(tolower(x), tolower(y)) == T, 1, 0) # find in the string
    }
    # set threshold = 1 for exact match
    if (!separated)  {  # search only a single string
      ifelse(stringdist::stringsim(tolower(x), tolower(y)) >= threshold, 1, 0)
    }}} ; is.match <- strings.match <- answer_match # replicated


str_ab <- function(x, char = ": ") {
  prefix = sub(paste0(char,".*"), "", x)
  suffix = sub(paste0(".*",char), "", x)
  return(list(prefix = prefix, suffix = suffix))
}

random.letter <- function(x, letters = "middle") {
  if (letters == "all") {
     s = sample(seq(nchar(x)-1, from = 2), 1)
     substr(x, s, s)
  } 
  if (letters == "middle") {
     s = sample(seq(nchar(x)), 1); 
     substr(x, s, s)
  }
}

#####################################################################################################
# from http://addictedtor.free.fr/packages/A2R/lastVersion/R/code.R
# http://gallery.r-enthusiasts.com/RGraphGallery.php?graph=79

"._a2r_hclu"       <- NULL # to receive an hclust object when 
                           # A2Rplot.hclust is called

"._a2r_counter"       <- NA # a counter used in A2Rplot.hclust
"._a2r_height_cut"    <- NA

"._a2r_envir"         <- NA
"._a2r_group"         <- NA


#===============================================================================
"A2Rplot" <- function(x,...){
  UseMethod("A2Rplot")
}
#===============================================================================
"A2Rplot.default" <- function(x,...){
  plot(x,...)
}
#===============================================================================
"A2Rplot.hclust" <- function(
  x ,             # an hclust object to draw
  k        = 2,   # the number of groups
  col.up   = "black",
  col.down = rainbow(k),
  lty.up   = 2,
  lty.down = 1,
  lwd.up   = 1,
  lwd.down = 2,
  type     = c("rectangle","triangle"),
  knot.pos = c("mean","bary","left","right","random"),
  criteria,
  fact.sup,
  show.labels=TRUE,
  only.tree=FALSE,
  main     = paste("Colored Dendrogram (",k," groups)"),
  boxes    = TRUE,
  members,
  ...
){

  if(missing(members)) members <- NULL
  opar <- par(no.readonly=TRUE)
  knot.pos <- match.arg(knot.pos)
  type     <- match.arg(type)
  # tests
  if(k<2) 
    stop("k must be at least 2")  
    
  ._a2r_counter    <<- 0
  ._a2r_hclu       <<- x

  ._a2r_envir      <<- environment()
  nn <- length(x$order) - 1

  ._a2r_height_cut <<- mean(x$height[nn-k+1:2])
  ._a2r_group      <<- 0
  
  n.indiv   <- length(x$order)
  groups.o  <- cutree.order(x, k=k)[x$order]
  
  bottom <- if(is.null(members)) 0 else x$height[nn] * -.2 
  
  if(only.tree){
    if(is.null(members)) plot(0,type="n",xlim=c(0.5,n.indiv+.5), ylim=c(bottom,x$height[nn]), xaxs="i", axes=FALSE, xlab="",ylab="") 
    else                 plot(0,type="n",xlim=c(0.5,sum(members)+.5), ylim=c(bottom,x$height[nn]), xaxs="i", axes=FALSE, xlab="",ylab="")
    #call to the ** recursive function ** .rec.hclust
    .rec.hclust(nn, col=col.up, lty=lty.up, lwd=lwd.up)
    
    if(boxes){
      axis(2)
      box()
    }
    return(NULL)
  }
  
  # prepare the layout
  matlayout <- matrix(c(2,4,6,1,3,5), nc=2, nr=3)
  widths    <- c(1,9)
  heights   <- c(8,1,1)
  if(!show.labels){
      matlayout <- matrix(c(2,4,1,3), nc=2, nr=2)
      widths    <- c(1,9)
      heights   <- c(9,1)
  }
  if(!missing(fact.sup) ) {
    heights   <- c(8,1,1)
  }
  if(missing(criteria) & missing(fact.sup)){
    matlayout <- matrix(c(2,4,1,3), nc=2, nr=2)
      widths    <- c(1,9)
      heights   <- c(9,1)
    
  }
  layout(matlayout, width=widths, height=heights)
  
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ The tree (1)
  par(mar=c(0,0,3,4))
  if(is.null(members)) plot(0,type="n",xlim=c(0.5,n.indiv+.5), ylim=c(bottom,x$height[nn]), xaxs="i", axes=FALSE, xlab="",ylab="") 
  else plot(0,type="n",xlim=c(0.5,sum(members)+.5), ylim=c(bottom,x$height[nn]), xaxs="i", axes=FALSE, xlab="",ylab="") 
  #call to the ** recursive function ** .rec.hclust
  .rec.hclust(nn, col=col.up, lty=lty.up, lwd=lwd.up)
  title(main)
  if(boxes){
    box()
    axis(4)
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Criteria (2)
  if(!missing(criteria)){
    par(mar=c(0,0,3,0))
    plot(0,
         type="n",
         xlim=range(criteria), 
         ylim=c(0,x$height[nn]), 
         axes=FALSE, 
         xlab="",
         ylab="")
    par(las=2)
    n.crit <- length(criteria)
    heights.cut <- ( tail(x$height,n.crit) + 
                     tail(x$height,n.crit+1)[-(n.crit+1)] ) / 2
    heights.cut <- rev(heights.cut)
                   
    points(criteria   , heights.cut   , pch=21, bg="red", type="o")
    points(criteria[k-1], heights.cut[k-1], pch=21, cex=2, bg="blue", xpd=NA)
    if(boxes){
      axis(3)
      box()
    }
  }
  else{
    par(mar=c(0,0,3,0))
    plot(0,
         type="n",
         xlim=c(0,1), 
         ylim=c(0,1), 
         axes=FALSE, 
         xlab="",
         ylab="")
  }

  if(show.labels){
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Name of the observations (3)
    par(mar=c(0,0,0,4))
    par(srt=90)
    obs.labels <- toupper(substr(x$labels[x$order],1,6))
    if(is.null(members)) {
      plot(0,type="n",xlim=c(0.5,n.indiv+.5), ylim=c(0,1), xaxs="i", axes=FALSE, xlab="",ylab="") 
      text(1:n.indiv            , 0, obs.labels, pos=4, col=col.down[groups.o])
    }
    else{
      plot(0,type="n",xlim=c(0.5,sum(members)+.5), ylim=c(0,1), xaxs="i", axes=FALSE, xlab="",ylab="") 
      xo <-   members[x$order]
      text(cumsum(xo)-xo/2, 0, obs.labels, pos=4, col=col.down[groups.o])
    }
    par(srt=0)
    if(boxes){
      box()
    }
  
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Labels (4)
    par(mar=c(0,0,0,0))
    plot(0,type="n",xlim=c(0,1), ylim=c(0,1), xaxs="i", axes=FALSE, xlab="",ylab="") 
    text(.5,.5,"Labels")
    if(boxes){
      box()
    }
      
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Quali (5,6)
  if(!missing(fact.sup)){
    quali  <- as.factor(fact.sup)[x$order]
    quanti <- as.numeric(quali)

    par(mar=c(1,0,0,4))
    n.levels <- length(levels(quali))
    plot(0,type="n",
         xlim=c(0.5,n.indiv+.5), 
         ylim=c(0,n.levels), 
         xaxs="i", yaxs="i",axes=FALSE, xlab="",ylab="") 
        
    rect(xleft    = (1:n.indiv)-.5,
         xright   = (1:n.indiv)+.5,
         ybottom  = quanti-1, 
         ytop     = quanti,
         col      = col.down[groups.o])
    par(las=1)
    axis(4, (1:n.levels)-.5,levels(quali), tick=FALSE)
      
    if(boxes){
      box()
    }
    
    
    par(mar=c(1,0,0,0))
    plot(0,type="n",xlim=c(0,1), ylim=c(0,1), xaxs="i", axes=FALSE, xlab="",ylab="") 
    text(.5,.5,deparse(substitute(fact.sup)))
    if(boxes){
      box()
    }
  }
  
  
  par(opar) # reset parameter
}

#===============================================================================

".rec.hclust" <- function(
  index, # index of the current tree to draw
  lwd = 1,
  lty = 1,
  col = "black"){

  members <- get('members', envir= ._a2r_envir) 
  bottom  <- get('bottom',  envir= ._a2r_envir) 
  if(index<0){ # it is a leaf
    if(is.null(members)){
       ._a2r_counter <<- ._a2r_counter + 1
       return(list( x = ._a2r_counter,
                    n = 1))       
    }
    else{
      cc <- ._a2r_counter
      mm <- members[-index]
      polygon(x  = c(cc, cc+mm/2, cc+mm),
              y  = c(bottom, 0, bottom),
              col= col, 
              border = col, 
              lwd=lwd)
      ._a2r_counter <<- ._a2r_counter + mm
      return(list(x = cc+mm/2,
                  n = mm))
    }
  }
  
  h.m   <- ._a2r_hclu$height[index]

  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~ do left
  index.l  <- ._a2r_hclu$merge[index,1]
  
  h.l <- if(index.l<0) 0 else ._a2r_hclu$height[index.l]
  if(h.l<._a2r_height_cut & h.m > ._a2r_height_cut){
      ._a2r_group <<- ._a2r_group + 1
      col.l <- get("col.down",envir=._a2r_envir)[._a2r_group]
      lwd.l <- get("lwd.down",envir=._a2r_envir)
      lty.l <- get("lty.down",envir=._a2r_envir)
  }
  else{
      col.l <- col
      lwd.l <- lwd
      lty.l <- lty
  }
  out.l   <- .rec.hclust(index.l, col=col.l, lty=lty.l, lwd=lwd.l)
  x.l     <- out.l$x
  n.l     <- out.l$n
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~ do right
  index.r  <- ._a2r_hclu$merge[index,2]
  h.r <- if(index.r<0) 0 else ._a2r_hclu$height[index.r]
  if(h.r<._a2r_height_cut & h.m > ._a2r_height_cut){
      ._a2r_group <<- ._a2r_group + 1
      col.r <- get("col.down",envir=._a2r_envir)[._a2r_group]
      lwd.r <- get("lwd.down",envir=._a2r_envir)
      lty.r <- get("lty.down",envir=._a2r_envir)
  }
  else{
      col.r <- col
      lwd.r <- lwd
      lty.r <- lty
  }
  out.r   <- .rec.hclust(index.r, col=col.r, lty=lty.r, lwd=lwd.r)
  x.r     <- out.r$x
  n.r     <- out.r$n
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~ draw what you have to draw
  
  type <- get("type",envir=._a2r_envir)
  x.m  <- (x.r + x.l) / 2  
  n    <- n.r + n.l
  x.b  <- (n.r * x.r + n.l * x.l) / n

  
  knot.pos <- get("knot.pos",envir=._a2r_envir) 
  
  x <- switch(knot.pos,
          mean = x.m,
          left = x.l,
          right= x.r,
          random = x.l + runif(1)*(x.r-x.l),
          bary   = x.b)

          
          
  if(type=="rectangle"){
    segments(x0  = c(x.l, x.l, x.r),
             x1  = c(x.l, x.r, x.r),
             y0  = c(h.l, h.m, h.r),
             y1  = c(h.m, h.m, h.m),
             col = col,
             lty = lty,
             lwd = lwd)
  }
  if(type =="triangle"){
    segments(x0  = c(x.l, x.r),
             x1  = c(x  , x),
             y0  = c(h.l, h.r),
             y1  = c(h.m, h.m),
             col = col,
             lty = lty,
             lwd = lwd)
  }
          
          
  list(x=x,n=n)
}
#===============================================================================
"cutree.order" <- function(hclu, k=NULL, h=NULL){
  
  coupe <- cutree(hclu,k=k, h=h)

  coupe.or <- coupe[hclu$order]
  coupe.out<- rep(NA,length(coupe))
  j <-  1 #
  k <-  coupe.or[1]
  for(i in 1:length(coupe)){
    if(coupe.or[i]==k) next
    else{
      coupe.out[which(coupe==k)] <- j
      j <- j + 1
      k <- coupe.or[i]
    }
  }
  coupe.out[is.na(coupe.out)] <- j
  names(coupe.out) <- names(coupe)
  coupe.out
}
#===============================================================================
#############################################################################################

#############################################################################################
#+++++++++++++++++++++++++
# Computing of correlation matrix
# from http://www.sthda.com/english/wiki/correlation-matrix-an-r-function-to-do-all-you-need#description-of-rquery.cormat-function
#+++++++++++++++++++++++++
# Required package : corrplot
# x : matrix
# type: possible values are "lower" (default), "upper", "full" or "flatten";
  #display lower or upper triangular of the matrix, full  or flatten matrix.
# graph : if TRUE, a correlogram or heatmap is plotted
# graphType : possible values are "correlogram" or "heatmap"
# col: colors to use for the correlogram
# ... : Further arguments to be passed to cor or cor.test function
# Result is a list including the following components :
  # r : correlation matrix, p :  p-values
  # sym : Symbolic number coding of the correlation matrix
rquery.cormat<-function(x,
                        type=c('lower', 'upper', 'full', 'flatten'),
                        graph=TRUE,
                        graphType=c("correlogram", "heatmap"),
                        col=NULL, ...)
{
  library(corrplot)
  # Helper functions
  #+++++++++++++++++
  # Compute the matrix of correlation p-values
  cor.pmat <- function(x, ...) {
    mat <- as.matrix(x)
    n <- ncol(mat)
    p.mat <- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
      for (j in (i + 1):n) {
        tmp <- cor.test(mat[, i], mat[, j], ...)
        p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
      }
    }
    colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
    p.mat
  }
  # Get lower triangle of the matrix
  getLower.tri<-function(mat){
    upper<-mat
    upper[upper.tri(mat)]<-""
    mat<-as.data.frame(upper)
    mat
  }
  # Get upper triangle of the matrix
  getUpper.tri<-function(mat){
    lt<-mat
    lt[lower.tri(mat)]<-""
    mat<-as.data.frame(lt)
    mat
  }
  # Get flatten matrix
  flattenCorrMatrix <- function(cormat, pmat) {
    ut <- upper.tri(cormat)
    data.frame(
      row = rownames(cormat)[row(cormat)[ut]],
      column = rownames(cormat)[col(cormat)[ut]],
      cor  =(cormat)[ut],
      p = pmat[ut]
    )
  }
  # Define color
  if (is.null(col)) {
    col <- colorRampPalette(
            c("#67001F", "#B2182B", "#D6604D", "#F4A582",
              "#FDDBC7", "#FFFFFF", "#D1E5F0", "#92C5DE", 
             "#4393C3", "#2166AC", "#053061"))(200)
    col<-rev(col)
  }
  
  # Correlation matrix
  cormat<-signif(cor(x, use = "complete.obs", ...),2)
  pmat<-signif(cor.pmat(x, ...),2)
  # Reorder correlation matrix
  ord<-corrMatOrder(cormat, order="hclust")
  cormat<-cormat[ord, ord]
  pmat<-pmat[ord, ord]
  # Replace correlation coeff by symbols
  sym<-symnum(cormat, abbr.colnames=FALSE)
  # Correlogram
  if(graph & graphType[1]=="correlogram"){
    corrplot(cormat, type=ifelse(type[1]=="flatten", "lower", type[1]),
             tl.col="black", tl.srt=45,col=col,...)
  }
  else if(graphType[1]=="heatmap")
    heatmap(cormat, col=col, symm=TRUE)
  # Get lower/upper triangle
  if(type[1]=="lower"){
    cormat<-getLower.tri(cormat)
    pmat<-getLower.tri(pmat)
  }
  else if(type[1]=="upper"){
    cormat<-getUpper.tri(cormat)
    pmat<-getUpper.tri(pmat)
    sym=t(sym)
  }
  else if(type[1]=="flatten"){
    cormat<-flattenCorrMatrix(cormat, pmat)
    pmat=NULL
    sym=NULL
  }
  list(r=cormat, p=pmat, sym=sym)
}

#############################################################################################

vectorList <- function(
# create a list of size n and name the list items
  vector = seq(from = 2018, to = as.numeric(format(Sys.Date(), format = "%Y")), by = 1),
  n = NULL,
  names = T
  ) {
  
  # create the list of length n
  if (is.null(n)) {     n = length(vector)  }  
  L = vector("list", length = n)

  if (!names) {     names(L) = letters[1:n]
  } else {          names(L) = vector
  }
  return(L)
}

